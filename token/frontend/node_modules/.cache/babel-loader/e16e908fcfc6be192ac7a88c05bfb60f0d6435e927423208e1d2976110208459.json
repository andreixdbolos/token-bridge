{"ast":null,"code":"import { toB64 } from \"@mysten/bcs\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport { bcs } from \"../bcs/index.js\";\nimport { IntentScope, messageWithIntent } from \"./intent.js\";\nimport { toSerializedSignature } from \"./signature.js\";\nconst PRIVATE_KEY_SIZE = 32;\nconst LEGACY_PRIVATE_KEY_SIZE = 64;\nclass BaseSigner {\n  /**\n   * Sign messages with a specific intent. By combining the message bytes with the intent before hashing and signing,\n   * it ensures that a signed message is tied to a specific purpose and domain separator is provided\n   */\n  async signWithIntent(bytes, intent) {\n    const intentMessage = messageWithIntent(intent, bytes);\n    const digest = blake2b(intentMessage, {\n      dkLen: 32\n    });\n    const signature = toSerializedSignature({\n      signature: await this.sign(digest),\n      signatureScheme: this.getKeyScheme(),\n      publicKey: this.getPublicKey()\n    });\n    return {\n      signature,\n      bytes: toB64(bytes)\n    };\n  }\n  /**\n   * Signs provided transaction block by calling `signWithIntent()` with a `TransactionData` provided as intent scope\n   */\n  async signTransactionBlock(bytes) {\n    return this.signWithIntent(bytes, IntentScope.TransactionData);\n  }\n  /**\n   * Signs provided personal message by calling `signWithIntent()` with a `PersonalMessage` provided as intent scope\n   */\n  async signPersonalMessage(bytes) {\n    return this.signWithIntent(bcs.vector(bcs.u8()).serialize(bytes).toBytes(), IntentScope.PersonalMessage);\n  }\n  toSuiAddress() {\n    return this.getPublicKey().toSuiAddress();\n  }\n}\nclass Keypair extends BaseSigner {}\nexport { BaseSigner, Keypair, LEGACY_PRIVATE_KEY_SIZE, PRIVATE_KEY_SIZE };","map":{"version":3,"names":["toB64","blake2b","bcs","IntentScope","messageWithIntent","toSerializedSignature","PRIVATE_KEY_SIZE","LEGACY_PRIVATE_KEY_SIZE","BaseSigner","signWithIntent","bytes","intent","intentMessage","digest","dkLen","signature","sign","signatureScheme","getKeyScheme","publicKey","getPublicKey","signTransactionBlock","TransactionData","signPersonalMessage","vector","u8","serialize","toBytes","PersonalMessage","toSuiAddress","Keypair"],"sources":["/home/andrei/proiect-itb/token/frontend/node_modules/@mysten/sui.js/src/cryptography/keypair.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB64 } from '@mysten/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\n\nimport { bcs } from '../bcs/index.js';\nimport { IntentScope, messageWithIntent } from './intent.js';\nimport type { PublicKey } from './publickey.js';\nimport type { SignatureScheme } from './signature-scheme.js';\nimport type { SerializedSignature } from './signature.js';\nimport { toSerializedSignature } from './signature.js';\n\nexport const PRIVATE_KEY_SIZE = 32;\nexport const LEGACY_PRIVATE_KEY_SIZE = 64;\n\nexport type ExportedKeypair = {\n\tschema: SignatureScheme;\n\tprivateKey: string;\n};\n\nexport interface SignatureWithBytes {\n\tbytes: string;\n\tsignature: SerializedSignature;\n}\n\n/**\n * TODO: Document\n */\nexport abstract class BaseSigner {\n\tabstract sign(bytes: Uint8Array): Promise<Uint8Array>;\n\t/**\n\t * Sign messages with a specific intent. By combining the message bytes with the intent before hashing and signing,\n\t * it ensures that a signed message is tied to a specific purpose and domain separator is provided\n\t */\n\tasync signWithIntent(bytes: Uint8Array, intent: IntentScope): Promise<SignatureWithBytes> {\n\t\tconst intentMessage = messageWithIntent(intent, bytes);\n\t\tconst digest = blake2b(intentMessage, { dkLen: 32 });\n\n\t\tconst signature = toSerializedSignature({\n\t\t\tsignature: await this.sign(digest),\n\t\t\tsignatureScheme: this.getKeyScheme(),\n\t\t\tpublicKey: this.getPublicKey(),\n\t\t});\n\n\t\treturn {\n\t\t\tsignature,\n\t\t\tbytes: toB64(bytes),\n\t\t};\n\t}\n\t/**\n\t * Signs provided transaction block by calling `signWithIntent()` with a `TransactionData` provided as intent scope\n\t */\n\tasync signTransactionBlock(bytes: Uint8Array) {\n\t\treturn this.signWithIntent(bytes, IntentScope.TransactionData);\n\t}\n\t/**\n\t * Signs provided personal message by calling `signWithIntent()` with a `PersonalMessage` provided as intent scope\n\t */\n\tasync signPersonalMessage(bytes: Uint8Array) {\n\t\treturn this.signWithIntent(\n\t\t\tbcs.vector(bcs.u8()).serialize(bytes).toBytes(),\n\t\t\tIntentScope.PersonalMessage,\n\t\t);\n\t}\n\n\ttoSuiAddress(): string {\n\t\treturn this.getPublicKey().toSuiAddress();\n\t}\n\n\t/**\n\t * Return the signature for the data.\n\t * Prefer the async version {@link sign}, as this method will be deprecated in a future release.\n\t */\n\tabstract signData(data: Uint8Array): Uint8Array;\n\n\t/**\n\t * Get the key scheme of the keypair: Secp256k1 or ED25519\n\t */\n\tabstract getKeyScheme(): SignatureScheme;\n\n\t/**\n\t * The public key for this keypair\n\t */\n\tabstract getPublicKey(): PublicKey;\n}\n\n/**\n * TODO: Document\n */\nexport abstract class Keypair extends BaseSigner {\n\tabstract export(): ExportedKeypair;\n}\n"],"mappings":"AAGA,SAASA,KAAA,QAAa;AACtB,SAASC,OAAA,QAAe;AAExB,SAASC,GAAA,QAAW;AACpB,SAASC,WAAA,EAAaC,iBAAA,QAAyB;AAI/C,SAASC,qBAAA,QAA6B;AAE/B,MAAMC,gBAAA,GAAmB;AACzB,MAAMC,uBAAA,GAA0B;AAehC,MAAeC,UAAA,CAAW;EAAA;AAAA;AAAA;AAAA;EAMhC,MAAMC,eAAeC,KAAA,EAAmBC,MAAA,EAAkD;IACzF,MAAMC,aAAA,GAAgBR,iBAAA,CAAkBO,MAAA,EAAQD,KAAK;IACrD,MAAMG,MAAA,GAASZ,OAAA,CAAQW,aAAA,EAAe;MAAEE,KAAA,EAAO;IAAG,CAAC;IAEnD,MAAMC,SAAA,GAAYV,qBAAA,CAAsB;MACvCU,SAAA,EAAW,MAAM,KAAKC,IAAA,CAAKH,MAAM;MACjCI,eAAA,EAAiB,KAAKC,YAAA,CAAa;MACnCC,SAAA,EAAW,KAAKC,YAAA,CAAa;IAC9B,CAAC;IAED,OAAO;MACNL,SAAA;MACAL,KAAA,EAAOV,KAAA,CAAMU,KAAK;IACnB;EACD;EAAA;AAAA;AAAA;EAIA,MAAMW,qBAAqBX,KAAA,EAAmB;IAC7C,OAAO,KAAKD,cAAA,CAAeC,KAAA,EAAOP,WAAA,CAAYmB,eAAe;EAC9D;EAAA;AAAA;AAAA;EAIA,MAAMC,oBAAoBb,KAAA,EAAmB;IAC5C,OAAO,KAAKD,cAAA,CACXP,GAAA,CAAIsB,MAAA,CAAOtB,GAAA,CAAIuB,EAAA,CAAG,CAAC,EAAEC,SAAA,CAAUhB,KAAK,EAAEiB,OAAA,CAAQ,GAC9CxB,WAAA,CAAYyB,eACb;EACD;EAEAC,aAAA,EAAuB;IACtB,OAAO,KAAKT,YAAA,CAAa,EAAES,YAAA,CAAa;EACzC;AAiBD;AAKO,MAAeC,OAAA,SAAgBtB,UAAA,CAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}