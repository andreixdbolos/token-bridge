{"ast":null,"code":"import { bcs, BCS as BcsRegistry, fromB58, fromHEX, getSuiMoveConfig, toB58, toHEX } from \"@mysten/bcs\";\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from \"../utils/sui-types.js\";\nimport { TypeTagSerializer } from \"./type-tag-serializer.js\";\nimport { TypeTagSerializer as TypeTagSerializer2 } from \"./type-tag-serializer.js\";\nfunction isPureArg(arg) {\n  return arg.Pure !== void 0;\n}\nconst bcsRegistry = new BcsRegistry({\n  ...getSuiMoveConfig(),\n  types: {\n    enums: {\n      \"Option<T>\": {\n        None: null,\n        Some: \"T\"\n      }\n    }\n  }\n});\nfunction unsafe_u64(options) {\n  return bcs.u64({\n    name: \"unsafe_u64\",\n    ...options\n  }).transform({\n    input: val => val,\n    output: val => Number(val)\n  });\n}\nfunction optionEnum(type) {\n  return bcs.enum(\"Option\", {\n    None: null,\n    Some: type\n  });\n}\nfunction enumKind(type) {\n  return type.transform({\n    input: val => ({\n      [val.kind]: val\n    }),\n    output: val => {\n      const key = Object.keys(val)[0];\n      return {\n        kind: key,\n        ...val[key]\n      };\n    }\n  });\n}\nconst Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n  input: val => typeof val === \"string\" ? fromHEX(normalizeSuiAddress(val)) : val,\n  output: val => normalizeSuiAddress(toHEX(val))\n});\nconst ObjectDigest = bcs.vector(bcs.u8()).transform({\n  name: \"ObjectDigest\",\n  input: value => fromB58(value),\n  output: value => toB58(new Uint8Array(value))\n});\nconst SuiObjectRef = bcs.struct(\"SuiObjectRef\", {\n  objectId: Address,\n  version: bcs.u64(),\n  digest: ObjectDigest\n});\nconst SharedObjectRef = bcs.struct(\"SharedObjectRef\", {\n  objectId: Address,\n  initialSharedVersion: bcs.u64(),\n  mutable: bcs.bool()\n});\nconst ObjectArg = bcs.enum(\"ObjectArg\", {\n  ImmOrOwned: SuiObjectRef,\n  Shared: SharedObjectRef,\n  Receiving: SuiObjectRef\n});\nconst CallArg = bcs.enum(\"CallArg\", {\n  Pure: bcs.vector(bcs.u8()),\n  Object: ObjectArg,\n  ObjVec: bcs.vector(ObjectArg)\n});\nconst TypeTag = bcs.enum(\"TypeTag\", {\n  bool: null,\n  u8: null,\n  u64: null,\n  u128: null,\n  address: null,\n  signer: null,\n  vector: bcs.lazy(() => TypeTag),\n  struct: bcs.lazy(() => StructTag),\n  u16: null,\n  u32: null,\n  u256: null\n});\nconst Argument = enumKind(bcs.enum(\"Argument\", {\n  GasCoin: null,\n  Input: bcs.struct(\"Input\", {\n    index: bcs.u16()\n  }),\n  Result: bcs.struct(\"Result\", {\n    index: bcs.u16()\n  }),\n  NestedResult: bcs.struct(\"NestedResult\", {\n    index: bcs.u16(),\n    resultIndex: bcs.u16()\n  })\n}));\nconst ProgrammableMoveCall = bcs.struct(\"ProgrammableMoveCall\", {\n  package: Address,\n  module: bcs.string(),\n  function: bcs.string(),\n  type_arguments: bcs.vector(TypeTag),\n  arguments: bcs.vector(Argument)\n}).transform({\n  input: data => {\n    const [pkg, module, fun] = data.target.split(\"::\");\n    const type_arguments = data.typeArguments.map(tag => TypeTagSerializer.parseFromStr(tag, true));\n    return {\n      package: normalizeSuiAddress(pkg),\n      module,\n      function: fun,\n      type_arguments,\n      arguments: data.arguments\n    };\n  },\n  output: data => {\n    return {\n      target: [data.package, data.module, data.function].join(\"::\"),\n      arguments: data.arguments,\n      typeArguments: data.type_arguments.map(TypeTagSerializer.tagToString)\n    };\n  }\n});\nconst Transaction = enumKind(bcs.enum(\"Transaction\", {\n  /**\n   * A Move Call - any public Move function can be called via\n   * this transaction. The results can be used that instant to pass\n   * into the next transaction.\n   */\n  MoveCall: ProgrammableMoveCall,\n  /**\n   * Transfer vector of objects to a receiver.\n   */\n  TransferObjects: bcs.struct(\"TransferObjects\", {\n    objects: bcs.vector(Argument),\n    address: Argument\n  }),\n  /**\n   * Split `amount` from a `coin`.\n   */\n  SplitCoins: bcs.struct(\"SplitCoins\", {\n    coin: Argument,\n    amounts: bcs.vector(Argument)\n  }),\n  /**\n   * Merge Vector of Coins (`sources`) into a `destination`.\n   */\n  MergeCoins: bcs.struct(\"MergeCoins\", {\n    destination: Argument,\n    sources: bcs.vector(Argument)\n  }),\n  /**\n   * Publish a Move module.\n   */\n  Publish: bcs.struct(\"Publish\", {\n    modules: bcs.vector(bcs.vector(bcs.u8())),\n    dependencies: bcs.vector(Address)\n  }),\n  /**\n   * Build a vector of objects using the input arguments.\n   * It is impossible to construct a `vector<T: key>` otherwise,\n   * so this call serves a utility function.\n   */\n  MakeMoveVec: bcs.struct(\"MakeMoveVec\", {\n    type: optionEnum(TypeTag),\n    objects: bcs.vector(Argument)\n  }),\n  /**  */\n  Upgrade: bcs.struct(\"Upgrade\", {\n    modules: bcs.vector(bcs.vector(bcs.u8())),\n    dependencies: bcs.vector(Address),\n    packageId: Address,\n    ticket: Argument\n  })\n}));\nconst ProgrammableTransaction = bcs.struct(\"ProgrammableTransaction\", {\n  inputs: bcs.vector(CallArg),\n  transactions: bcs.vector(Transaction)\n});\nconst TransactionKind = bcs.enum(\"TransactionKind\", {\n  ProgrammableTransaction,\n  ChangeEpoch: null,\n  Genesis: null,\n  ConsensusCommitPrologue: null\n});\nconst TransactionExpiration = bcs.enum(\"TransactionExpiration\", {\n  None: null,\n  Epoch: unsafe_u64()\n});\nconst StructTag = bcs.struct(\"StructTag\", {\n  address: Address,\n  module: bcs.string(),\n  name: bcs.string(),\n  typeParams: bcs.vector(TypeTag)\n});\nconst GasData = bcs.struct(\"GasData\", {\n  payment: bcs.vector(SuiObjectRef),\n  owner: Address,\n  price: bcs.u64(),\n  budget: bcs.u64()\n});\nconst TransactionDataV1 = bcs.struct(\"TransactionDataV1\", {\n  kind: TransactionKind,\n  sender: Address,\n  gasData: GasData,\n  expiration: TransactionExpiration\n});\nconst TransactionData = bcs.enum(\"TransactionData\", {\n  V1: TransactionDataV1\n});\nconst SenderSignedData = bcs.struct(\"SenderSignedData\", {\n  data: TransactionData,\n  txSignatures: bcs.vector(bcs.vector(bcs.u8()))\n});\nconst CompressedSignature = bcs.enum(\"CompressedSignature\", {\n  ED25519: bcs.fixedArray(64, bcs.u8()),\n  Secp256k1: bcs.fixedArray(64, bcs.u8()),\n  Secp256r1: bcs.fixedArray(64, bcs.u8()),\n  ZkLogin: bcs.vector(bcs.u8())\n});\nconst PublicKey = bcs.enum(\"PublicKey\", {\n  ED25519: bcs.fixedArray(32, bcs.u8()),\n  Secp256k1: bcs.fixedArray(33, bcs.u8()),\n  Secp256r1: bcs.fixedArray(33, bcs.u8()),\n  ZkLogin: bcs.vector(bcs.u8())\n});\nconst MultiSigPkMap = bcs.struct(\"MultiSigPkMap\", {\n  pubKey: PublicKey,\n  weight: bcs.u8()\n});\nconst MultiSigPublicKey = bcs.struct(\"MultiSigPublicKey\", {\n  pk_map: bcs.vector(MultiSigPkMap),\n  threshold: bcs.u16()\n});\nconst MultiSig = bcs.struct(\"MultiSig\", {\n  sigs: bcs.vector(CompressedSignature),\n  bitmap: bcs.u16(),\n  multisig_pk: MultiSigPublicKey\n});\nconst suiBcs = {\n  ...bcs,\n  U8: bcs.u8(),\n  U16: bcs.u16(),\n  U32: bcs.u32(),\n  U64: bcs.u64(),\n  U128: bcs.u128(),\n  U256: bcs.u256(),\n  ULEB128: bcs.uleb128(),\n  Bool: bcs.bool(),\n  String: bcs.string(),\n  Address,\n  Argument,\n  CallArg,\n  CompressedSignature,\n  GasData,\n  MultiSig,\n  MultiSigPkMap,\n  MultiSigPublicKey,\n  ObjectArg,\n  ObjectDigest,\n  ProgrammableMoveCall,\n  ProgrammableTransaction,\n  PublicKey,\n  SenderSignedData,\n  SharedObjectRef,\n  StructTag,\n  SuiObjectRef,\n  Transaction,\n  TransactionData,\n  TransactionDataV1,\n  TransactionExpiration,\n  TransactionKind,\n  TypeTag,\n  // preserve backwards compatibility with old bcs export\n  ser: bcsRegistry.ser.bind(bcsRegistry),\n  de: bcsRegistry.de.bind(bcsRegistry),\n  getTypeInterface: bcsRegistry.getTypeInterface.bind(bcsRegistry),\n  hasType: bcsRegistry.hasType.bind(bcsRegistry),\n  parseTypeName: bcsRegistry.parseTypeName.bind(bcsRegistry),\n  registerAddressType: bcsRegistry.registerAddressType.bind(bcsRegistry),\n  registerAlias: bcsRegistry.registerAlias.bind(bcsRegistry),\n  registerBcsType: bcsRegistry.registerBcsType.bind(bcsRegistry),\n  registerEnumType: bcsRegistry.registerEnumType.bind(bcsRegistry),\n  registerStructType: bcsRegistry.registerStructType.bind(bcsRegistry),\n  registerType: bcsRegistry.registerType.bind(bcsRegistry),\n  types: bcsRegistry.types\n};\nbcsRegistry.registerBcsType(\"utf8string\", () => bcs.string({\n  name: \"utf8string\"\n}));\nbcsRegistry.registerBcsType(\"unsafe_u64\", () => unsafe_u64());\nbcsRegistry.registerBcsType(\"enumKind\", T => enumKind(T));\n[Address, Argument, CallArg, CompressedSignature, GasData, MultiSig, MultiSigPkMap, MultiSigPublicKey, ObjectArg, ObjectDigest, ProgrammableMoveCall, ProgrammableTransaction, PublicKey, SenderSignedData, SharedObjectRef, StructTag, SuiObjectRef, Transaction, TransactionData, TransactionDataV1, TransactionExpiration, TransactionKind, TypeTag].forEach(type => {\n  bcsRegistry.registerBcsType(type.name, () => type);\n});\nexport { TypeTagSerializer2 as TypeTagSerializer, suiBcs as bcs, bcsRegistry, isPureArg };","map":{"version":3,"names":["bcs","BCS","BcsRegistry","fromB58","fromHEX","getSuiMoveConfig","toB58","toHEX","normalizeSuiAddress","SUI_ADDRESS_LENGTH","TypeTagSerializer","TypeTagSerializer2","isPureArg","arg","Pure","bcsRegistry","types","enums","None","Some","unsafe_u64","options","u64","name","transform","input","val","output","Number","optionEnum","type","enum","enumKind","kind","key","Object","keys","Address","bytes","ObjectDigest","vector","u8","value","Uint8Array","SuiObjectRef","struct","objectId","version","digest","SharedObjectRef","initialSharedVersion","mutable","bool","ObjectArg","ImmOrOwned","Shared","Receiving","CallArg","ObjVec","TypeTag","u128","address","signer","lazy","StructTag","u16","u32","u256","Argument","GasCoin","Input","index","Result","NestedResult","resultIndex","ProgrammableMoveCall","package","module","string","function","type_arguments","arguments","data","pkg","fun","target","split","typeArguments","map","tag","parseFromStr","join","tagToString","Transaction","MoveCall","TransferObjects","objects","SplitCoins","coin","amounts","MergeCoins","destination","sources","Publish","modules","dependencies","MakeMoveVec","Upgrade","packageId","ticket","ProgrammableTransaction","inputs","transactions","TransactionKind","ChangeEpoch","Genesis","ConsensusCommitPrologue","TransactionExpiration","Epoch","typeParams","GasData","payment","owner","price","budget","TransactionDataV1","sender","gasData","expiration","TransactionData","V1","SenderSignedData","txSignatures","CompressedSignature","ED25519","fixedArray","Secp256k1","Secp256r1","ZkLogin","PublicKey","MultiSigPkMap","pubKey","weight","MultiSigPublicKey","pk_map","threshold","MultiSig","sigs","bitmap","multisig_pk","suiBcs","U8","U16","U32","U64","U128","U256","ULEB128","uleb128","Bool","String","ser","bind","de","getTypeInterface","hasType","parseTypeName","registerAddressType","registerAlias","registerBcsType","registerEnumType","registerStructType","registerType","T","forEach"],"sources":["/home/andrei/proiect-itb/token/frontend/node_modules/@mysten/sui.js/src/bcs/index.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n\tbcs,\n\tBCS as BcsRegistry,\n\tfromB58,\n\tfromHEX,\n\tgetSuiMoveConfig,\n\ttoB58,\n\ttoHEX,\n} from '@mysten/bcs';\nimport type { BcsType, BcsTypeOptions } from '@mysten/bcs';\n\nimport type { MoveCallTransaction } from '../builder/Transactions.js';\nimport type { SuiObjectRef as SuiObjectRefType } from '../types/objects.js';\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport { TypeTagSerializer } from './type-tag-serializer.js';\n\nexport { TypeTagSerializer } from './type-tag-serializer.js';\n\n/**\n * A reference to a shared object.\n */\nexport type SharedObjectRef = {\n\t/** Hex code as string representing the object id */\n\tobjectId: string;\n\n\t/** The version the object was shared at */\n\tinitialSharedVersion: number | string;\n\n\t/** Whether reference is mutable */\n\tmutable: boolean;\n};\n\n/**\n * An object argument.\n */\nexport type ObjectArg =\n\t| { ImmOrOwned: SuiObjectRefType }\n\t| { Shared: SharedObjectRef }\n\t| { Receiving: SuiObjectRefType };\n\n/**\n * A pure argument.\n */\nexport type PureArg = { Pure: ArrayLike<number> };\n\nexport function isPureArg(arg: any): arg is PureArg {\n\treturn (arg as PureArg).Pure !== undefined;\n}\n\n/**\n * An argument for the transaction. It is a 'meant' enum which expects to have\n * one of the optional properties. If not, the BCS error will be thrown while\n * attempting to form a transaction.\n *\n * Example:\n * ```js\n * let arg1: CallArg = { Object: { Shared: {\n *   objectId: '5460cf92b5e3e7067aaace60d88324095fd22944',\n *   initialSharedVersion: 1,\n *   mutable: true,\n * } } };\n * let arg2: CallArg = { Pure: bcs.ser(BCS.STRING, 100000).toBytes() };\n * let arg3: CallArg = { Object: { ImmOrOwned: {\n *   objectId: '4047d2e25211d87922b6650233bd0503a6734279',\n *   version: 1,\n *   digest: 'bCiANCht4O9MEUhuYjdRCqRPZjr2rJ8MfqNiwyhmRgA='\n * } } };\n * ```\n *\n * For `Pure` arguments BCS is required. You must encode the values with BCS according\n * to the type required by the called function. Pure accepts only serialized values\n */\nexport type CallArg = PureArg | { Object: ObjectArg };\n\n/**\n * Kind of a TypeTag which is represented by a Move type identifier.\n */\nexport type StructTag = {\n\taddress: string;\n\tmodule: string;\n\tname: string;\n\ttypeParams: TypeTag[];\n};\n\n/**\n * Sui TypeTag object. A decoupled `0x...::module::Type<???>` parameter.\n */\nexport type TypeTag =\n\t| { bool: null | true }\n\t| { u8: null | true }\n\t| { u64: null | true }\n\t| { u128: null | true }\n\t| { address: null | true }\n\t| { signer: null | true }\n\t| { vector: TypeTag }\n\t| { struct: StructTag }\n\t| { u16: null | true }\n\t| { u32: null | true }\n\t| { u256: null | true };\n\n// ========== TransactionData ===========\n\n/**\n * The GasData to be used in the transaction.\n */\nexport type GasData = {\n\tpayment: SuiObjectRefType[];\n\towner: string; // Gas Object's owner\n\tprice: number;\n\tbudget: number;\n};\n\n/**\n * TransactionExpiration\n *\n * Indications the expiration time for a transaction.\n */\nexport type TransactionExpiration = { None: null } | { Epoch: number };\n\nconst bcsRegistry = new BcsRegistry({\n\t...getSuiMoveConfig(),\n\ttypes: {\n\t\tenums: {\n\t\t\t'Option<T>': {\n\t\t\t\tNone: null,\n\t\t\t\tSome: 'T',\n\t\t\t},\n\t\t},\n\t},\n});\n\nfunction unsafe_u64(options?: BcsTypeOptions<number>) {\n\treturn bcs\n\t\t.u64({\n\t\t\tname: 'unsafe_u64',\n\t\t\t...(options as object),\n\t\t})\n\t\t.transform({\n\t\t\tinput: (val: number) => val,\n\t\t\toutput: (val) => Number(val),\n\t\t});\n}\n\nfunction optionEnum<T extends BcsType<any, any>>(type: T) {\n\treturn bcs.enum('Option', {\n\t\tNone: null,\n\t\tSome: type,\n\t});\n}\n\n/**\n * Wrapper around Enum, which transforms any `T` into an object with `kind` property:\n * @example\n * ```\n * let bcsEnum = { TransferObjects: { objects: [], address: ... } }\n * // becomes\n * let translatedEnum = { kind: 'TransferObjects', objects: [], address: ... };\n * ```\n */\nfunction enumKind<T extends object, Input extends object>(type: BcsType<T, Input>) {\n\ttype Merge<T> = T extends infer U ? { [K in keyof U]: U[K] } : never;\n\ttype EnumKindTransform<T> = T extends infer U\n\t\t? Merge<(U[keyof U] extends null | boolean ? object : U[keyof U]) & { kind: keyof U }>\n\t\t: never;\n\n\treturn type.transform({\n\t\tinput: (val: EnumKindTransform<Input>) =>\n\t\t\t({\n\t\t\t\t[val.kind]: val,\n\t\t\t}) as Input,\n\t\toutput: (val) => {\n\t\t\tconst key = Object.keys(val)[0] as keyof T;\n\n\t\t\treturn { kind: key, ...val[key] } as EnumKindTransform<T>;\n\t\t},\n\t});\n}\n\nconst Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n\tinput: (val: string | Uint8Array) =>\n\t\ttypeof val === 'string' ? fromHEX(normalizeSuiAddress(val)) : val,\n\toutput: (val) => normalizeSuiAddress(toHEX(val)),\n});\n\nconst ObjectDigest = bcs.vector(bcs.u8()).transform({\n\tname: 'ObjectDigest',\n\tinput: (value: string) => fromB58(value),\n\toutput: (value) => toB58(new Uint8Array(value)),\n});\n\nconst SuiObjectRef = bcs.struct('SuiObjectRef', {\n\tobjectId: Address,\n\tversion: bcs.u64(),\n\tdigest: ObjectDigest,\n});\n\nconst SharedObjectRef = bcs.struct('SharedObjectRef', {\n\tobjectId: Address,\n\tinitialSharedVersion: bcs.u64(),\n\tmutable: bcs.bool(),\n});\n\nconst ObjectArg = bcs.enum('ObjectArg', {\n\tImmOrOwned: SuiObjectRef,\n\tShared: SharedObjectRef,\n\tReceiving: SuiObjectRef,\n});\n\nconst CallArg = bcs.enum('CallArg', {\n\tPure: bcs.vector(bcs.u8()),\n\tObject: ObjectArg,\n\tObjVec: bcs.vector(ObjectArg),\n});\n\nconst TypeTag: BcsType<TypeTag> = bcs.enum('TypeTag', {\n\tbool: null,\n\tu8: null,\n\tu64: null,\n\tu128: null,\n\taddress: null,\n\tsigner: null,\n\tvector: bcs.lazy(() => TypeTag),\n\tstruct: bcs.lazy(() => StructTag),\n\tu16: null,\n\tu32: null,\n\tu256: null,\n}) as never;\n\nconst Argument = enumKind(\n\tbcs.enum('Argument', {\n\t\tGasCoin: null,\n\t\tInput: bcs.struct('Input', { index: bcs.u16() }),\n\t\tResult: bcs.struct('Result', { index: bcs.u16() }),\n\t\tNestedResult: bcs.struct('NestedResult', { index: bcs.u16(), resultIndex: bcs.u16() }),\n\t}),\n);\n\n/** Custom serializer for decoding package, module, function easier */\nconst ProgrammableMoveCall = bcs\n\t.struct('ProgrammableMoveCall', {\n\t\tpackage: Address,\n\t\tmodule: bcs.string(),\n\t\tfunction: bcs.string(),\n\t\ttype_arguments: bcs.vector(TypeTag),\n\t\targuments: bcs.vector(Argument),\n\t})\n\t.transform({\n\t\tinput: (data: MoveCallTransaction) => {\n\t\t\tconst [pkg, module, fun] = data.target.split('::');\n\t\t\tconst type_arguments = data.typeArguments.map((tag) =>\n\t\t\t\tTypeTagSerializer.parseFromStr(tag, true),\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tpackage: normalizeSuiAddress(pkg),\n\t\t\t\tmodule,\n\t\t\t\tfunction: fun,\n\t\t\t\ttype_arguments,\n\t\t\t\targuments: data.arguments,\n\t\t\t};\n\t\t},\n\t\toutput: (data) => {\n\t\t\treturn {\n\t\t\t\ttarget: [data.package, data.module, data.function].join(\n\t\t\t\t\t'::',\n\t\t\t\t) as `${string}::${string}::${string}`,\n\t\t\t\targuments: data.arguments,\n\t\t\t\ttypeArguments: data.type_arguments.map(TypeTagSerializer.tagToString),\n\t\t\t};\n\t\t},\n\t});\n\nconst Transaction = enumKind(\n\tbcs.enum('Transaction', {\n\t\t/**\n\t\t * A Move Call - any public Move function can be called via\n\t\t * this transaction. The results can be used that instant to pass\n\t\t * into the next transaction.\n\t\t */\n\t\tMoveCall: ProgrammableMoveCall,\n\t\t/**\n\t\t * Transfer vector of objects to a receiver.\n\t\t */\n\t\tTransferObjects: bcs.struct('TransferObjects', {\n\t\t\tobjects: bcs.vector(Argument),\n\t\t\taddress: Argument,\n\t\t}),\n\t\t/**\n\t\t * Split `amount` from a `coin`.\n\t\t */\n\t\tSplitCoins: bcs.struct('SplitCoins', { coin: Argument, amounts: bcs.vector(Argument) }),\n\t\t/**\n\t\t * Merge Vector of Coins (`sources`) into a `destination`.\n\t\t */\n\t\tMergeCoins: bcs.struct('MergeCoins', { destination: Argument, sources: bcs.vector(Argument) }),\n\t\t/**\n\t\t * Publish a Move module.\n\t\t */\n\t\tPublish: bcs.struct('Publish', {\n\t\t\tmodules: bcs.vector(bcs.vector(bcs.u8())),\n\t\t\tdependencies: bcs.vector(Address),\n\t\t}),\n\t\t/**\n\t\t * Build a vector of objects using the input arguments.\n\t\t * It is impossible to construct a `vector<T: key>` otherwise,\n\t\t * so this call serves a utility function.\n\t\t */\n\t\tMakeMoveVec: bcs.struct('MakeMoveVec', {\n\t\t\ttype: optionEnum(TypeTag),\n\t\t\tobjects: bcs.vector(Argument),\n\t\t}),\n\t\t/**  */\n\t\tUpgrade: bcs.struct('Upgrade', {\n\t\t\tmodules: bcs.vector(bcs.vector(bcs.u8())),\n\t\t\tdependencies: bcs.vector(Address),\n\t\t\tpackageId: Address,\n\t\t\tticket: Argument,\n\t\t}),\n\t}),\n);\n\nconst ProgrammableTransaction = bcs.struct('ProgrammableTransaction', {\n\tinputs: bcs.vector(CallArg),\n\ttransactions: bcs.vector(Transaction),\n});\n\nconst TransactionKind = bcs.enum('TransactionKind', {\n\tProgrammableTransaction: ProgrammableTransaction,\n\tChangeEpoch: null,\n\tGenesis: null,\n\tConsensusCommitPrologue: null,\n});\n\nconst TransactionExpiration = bcs.enum('TransactionExpiration', {\n\tNone: null,\n\tEpoch: unsafe_u64(),\n});\n\nconst StructTag = bcs.struct('StructTag', {\n\taddress: Address,\n\tmodule: bcs.string(),\n\tname: bcs.string(),\n\ttypeParams: bcs.vector(TypeTag),\n});\n\nconst GasData = bcs.struct('GasData', {\n\tpayment: bcs.vector(SuiObjectRef),\n\towner: Address,\n\tprice: bcs.u64(),\n\tbudget: bcs.u64(),\n});\n\nconst TransactionDataV1 = bcs.struct('TransactionDataV1', {\n\tkind: TransactionKind,\n\tsender: Address,\n\tgasData: GasData,\n\texpiration: TransactionExpiration,\n});\n\nconst TransactionData = bcs.enum('TransactionData', {\n\tV1: TransactionDataV1,\n});\n\n// Signed transaction data needed to generate transaction digest.\nconst SenderSignedData = bcs.struct('SenderSignedData', {\n\tdata: TransactionData,\n\ttxSignatures: bcs.vector(bcs.vector(bcs.u8())),\n});\n\nconst CompressedSignature = bcs.enum('CompressedSignature', {\n\tED25519: bcs.fixedArray(64, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(64, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(64, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n});\n\nconst PublicKey = bcs.enum('PublicKey', {\n\tED25519: bcs.fixedArray(32, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(33, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(33, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n});\n\nconst MultiSigPkMap = bcs.struct('MultiSigPkMap', {\n\tpubKey: PublicKey,\n\tweight: bcs.u8(),\n});\n\nconst MultiSigPublicKey = bcs.struct('MultiSigPublicKey', {\n\tpk_map: bcs.vector(MultiSigPkMap),\n\tthreshold: bcs.u16(),\n});\n\nconst MultiSig = bcs.struct('MultiSig', {\n\tsigs: bcs.vector(CompressedSignature),\n\tbitmap: bcs.u16(),\n\tmultisig_pk: MultiSigPublicKey,\n});\n\nconst suiBcs = {\n\t...bcs,\n\tU8: bcs.u8(),\n\tU16: bcs.u16(),\n\tU32: bcs.u32(),\n\tU64: bcs.u64(),\n\tU128: bcs.u128(),\n\tU256: bcs.u256(),\n\tULEB128: bcs.uleb128(),\n\tBool: bcs.bool(),\n\tString: bcs.string(),\n\tAddress,\n\tArgument,\n\tCallArg,\n\tCompressedSignature,\n\tGasData,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransaction,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n\n\t// preserve backwards compatibility with old bcs export\n\tser: bcsRegistry.ser.bind(bcsRegistry),\n\tde: bcsRegistry.de.bind(bcsRegistry),\n\tgetTypeInterface: bcsRegistry.getTypeInterface.bind(bcsRegistry),\n\thasType: bcsRegistry.hasType.bind(bcsRegistry),\n\tparseTypeName: bcsRegistry.parseTypeName.bind(bcsRegistry),\n\tregisterAddressType: bcsRegistry.registerAddressType.bind(bcsRegistry),\n\tregisterAlias: bcsRegistry.registerAlias.bind(bcsRegistry),\n\tregisterBcsType: bcsRegistry.registerBcsType.bind(bcsRegistry),\n\tregisterEnumType: bcsRegistry.registerEnumType.bind(bcsRegistry),\n\tregisterStructType: bcsRegistry.registerStructType.bind(bcsRegistry),\n\tregisterType: bcsRegistry.registerType.bind(bcsRegistry),\n\ttypes: bcsRegistry.types,\n};\n\nbcsRegistry.registerBcsType('utf8string', () => bcs.string({ name: 'utf8string' }));\nbcsRegistry.registerBcsType('unsafe_u64', () => unsafe_u64());\nbcsRegistry.registerBcsType('enumKind', (T) => enumKind(T));\n\n[\n\tAddress,\n\tArgument,\n\tCallArg,\n\tCompressedSignature,\n\tGasData,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransaction,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n].forEach((type) => {\n\tbcsRegistry.registerBcsType(type.name, () => type);\n});\n\nexport { suiBcs as bcs, bcsRegistry };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}