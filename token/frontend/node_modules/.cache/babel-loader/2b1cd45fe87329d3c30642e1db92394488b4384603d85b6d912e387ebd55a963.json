{"ast":null,"code":"import { extractStructTag } from \"../types/index.js\";\nimport { MOVE_STDLIB_ADDRESS, SUI_FRAMEWORK_ADDRESS } from \"../utils/index.js\";\nimport { isValidSuiAddress } from \"../utils/sui-types.js\";\nconst OBJECT_MODULE_NAME = \"object\";\nconst ID_STRUCT_NAME = \"ID\";\nconst STD_ASCII_MODULE_NAME = \"ascii\";\nconst STD_ASCII_STRUCT_NAME = \"String\";\nconst STD_UTF8_MODULE_NAME = \"string\";\nconst STD_UTF8_STRUCT_NAME = \"String\";\nconst STD_OPTION_MODULE_NAME = \"option\";\nconst STD_OPTION_STRUCT_NAME = \"Option\";\nconst RESOLVED_SUI_ID = {\n  address: SUI_FRAMEWORK_ADDRESS,\n  module: OBJECT_MODULE_NAME,\n  name: ID_STRUCT_NAME\n};\nconst RESOLVED_ASCII_STR = {\n  address: MOVE_STDLIB_ADDRESS,\n  module: STD_ASCII_MODULE_NAME,\n  name: STD_ASCII_STRUCT_NAME\n};\nconst RESOLVED_UTF8_STR = {\n  address: MOVE_STDLIB_ADDRESS,\n  module: STD_UTF8_MODULE_NAME,\n  name: STD_UTF8_STRUCT_NAME\n};\nconst RESOLVED_STD_OPTION = {\n  address: MOVE_STDLIB_ADDRESS,\n  module: STD_OPTION_MODULE_NAME,\n  name: STD_OPTION_STRUCT_NAME\n};\nconst isSameStruct = (a, b) => a.address === b.address && a.module === b.module && a.name === b.name;\nfunction isTxContext(param) {\n  const struct = extractStructTag(param)?.Struct;\n  return struct?.address === \"0x2\" && struct?.module === \"tx_context\" && struct?.name === \"TxContext\";\n}\nfunction expectType(typeName, argVal) {\n  if (typeof argVal === \"undefined\") {\n    return;\n  }\n  if (typeof argVal !== typeName) {\n    throw new Error(`Expect ${argVal} to be ${typeName}, received ${typeof argVal}`);\n  }\n}\nconst allowedTypes = [\"Address\", \"Bool\", \"U8\", \"U16\", \"U32\", \"U64\", \"U128\", \"U256\"];\nfunction getPureSerializationType(normalizedType, argVal) {\n  if (typeof normalizedType === \"string\" && allowedTypes.includes(normalizedType)) {\n    if (normalizedType in [\"U8\", \"U16\", \"U32\", \"U64\", \"U128\", \"U256\"]) {\n      expectType(\"number\", argVal);\n    } else if (normalizedType === \"Bool\") {\n      expectType(\"boolean\", argVal);\n    } else if (normalizedType === \"Address\") {\n      expectType(\"string\", argVal);\n      if (argVal && !isValidSuiAddress(argVal)) {\n        throw new Error(\"Invalid Sui Address\");\n      }\n    }\n    return normalizedType.toLowerCase();\n  } else if (typeof normalizedType === \"string\") {\n    throw new Error(`Unknown pure normalized type ${JSON.stringify(normalizedType, null, 2)}`);\n  }\n  if (\"Vector\" in normalizedType) {\n    if ((argVal === void 0 || typeof argVal === \"string\") && normalizedType.Vector === \"U8\") {\n      return \"string\";\n    }\n    if (argVal !== void 0 && !Array.isArray(argVal)) {\n      throw new Error(`Expect ${argVal} to be a array, received ${typeof argVal}`);\n    }\n    const innerType = getPureSerializationType(normalizedType.Vector,\n    // undefined when argVal is empty\n    argVal ? argVal[0] : void 0);\n    if (innerType === void 0) {\n      return;\n    }\n    return `vector<${innerType}>`;\n  }\n  if (\"Struct\" in normalizedType) {\n    if (isSameStruct(normalizedType.Struct, RESOLVED_ASCII_STR)) {\n      return \"string\";\n    } else if (isSameStruct(normalizedType.Struct, RESOLVED_UTF8_STR)) {\n      return \"utf8string\";\n    } else if (isSameStruct(normalizedType.Struct, RESOLVED_SUI_ID)) {\n      return \"address\";\n    } else if (isSameStruct(normalizedType.Struct, RESOLVED_STD_OPTION)) {\n      const optionToVec = {\n        Vector: normalizedType.Struct.typeArguments[0]\n      };\n      return getPureSerializationType(optionToVec, argVal);\n    }\n  }\n  return void 0;\n}\nexport { getPureSerializationType, isTxContext };","map":{"version":3,"names":["extractStructTag","MOVE_STDLIB_ADDRESS","SUI_FRAMEWORK_ADDRESS","isValidSuiAddress","OBJECT_MODULE_NAME","ID_STRUCT_NAME","STD_ASCII_MODULE_NAME","STD_ASCII_STRUCT_NAME","STD_UTF8_MODULE_NAME","STD_UTF8_STRUCT_NAME","STD_OPTION_MODULE_NAME","STD_OPTION_STRUCT_NAME","RESOLVED_SUI_ID","address","module","name","RESOLVED_ASCII_STR","RESOLVED_UTF8_STR","RESOLVED_STD_OPTION","isSameStruct","a","b","isTxContext","param","struct","Struct","expectType","typeName","argVal","Error","allowedTypes","getPureSerializationType","normalizedType","includes","toLowerCase","JSON","stringify","Vector","Array","isArray","innerType","optionToVec","typeArguments"],"sources":["/home/andrei/proiect-itb/token/frontend/node_modules/@mysten/sui.js/src/builder/serializer.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SuiJsonValue, SuiMoveNormalizedType } from '../client/index.js';\nimport { extractStructTag } from '../types/index.js';\nimport { MOVE_STDLIB_ADDRESS, SUI_FRAMEWORK_ADDRESS } from '../utils/index.js';\nimport { isValidSuiAddress } from '../utils/sui-types.js';\n\nconst OBJECT_MODULE_NAME = 'object';\nconst ID_STRUCT_NAME = 'ID';\n\nconst STD_ASCII_MODULE_NAME = 'ascii';\nconst STD_ASCII_STRUCT_NAME = 'String';\n\nconst STD_UTF8_MODULE_NAME = 'string';\nconst STD_UTF8_STRUCT_NAME = 'String';\n\nconst STD_OPTION_MODULE_NAME = 'option';\nconst STD_OPTION_STRUCT_NAME = 'Option';\n\nconst RESOLVED_SUI_ID = {\n\taddress: SUI_FRAMEWORK_ADDRESS,\n\tmodule: OBJECT_MODULE_NAME,\n\tname: ID_STRUCT_NAME,\n};\nconst RESOLVED_ASCII_STR = {\n\taddress: MOVE_STDLIB_ADDRESS,\n\tmodule: STD_ASCII_MODULE_NAME,\n\tname: STD_ASCII_STRUCT_NAME,\n};\nconst RESOLVED_UTF8_STR = {\n\taddress: MOVE_STDLIB_ADDRESS,\n\tmodule: STD_UTF8_MODULE_NAME,\n\tname: STD_UTF8_STRUCT_NAME,\n};\n\nconst RESOLVED_STD_OPTION = {\n\taddress: MOVE_STDLIB_ADDRESS,\n\tmodule: STD_OPTION_MODULE_NAME,\n\tname: STD_OPTION_STRUCT_NAME,\n};\n\nconst isSameStruct = (a: any, b: any) =>\n\ta.address === b.address && a.module === b.module && a.name === b.name;\n\nexport function isTxContext(param: SuiMoveNormalizedType): boolean {\n\tconst struct = extractStructTag(param)?.Struct;\n\treturn (\n\t\tstruct?.address === '0x2' && struct?.module === 'tx_context' && struct?.name === 'TxContext'\n\t);\n}\n\nfunction expectType(typeName: string, argVal?: SuiJsonValue) {\n\tif (typeof argVal === 'undefined') {\n\t\treturn;\n\t}\n\tif (typeof argVal !== typeName) {\n\t\tthrow new Error(`Expect ${argVal} to be ${typeName}, received ${typeof argVal}`);\n\t}\n}\n\nconst allowedTypes = ['Address', 'Bool', 'U8', 'U16', 'U32', 'U64', 'U128', 'U256'];\n\nexport function getPureSerializationType(\n\tnormalizedType: SuiMoveNormalizedType,\n\targVal: SuiJsonValue | undefined,\n): string | undefined {\n\tif (typeof normalizedType === 'string' && allowedTypes.includes(normalizedType)) {\n\t\tif (normalizedType in ['U8', 'U16', 'U32', 'U64', 'U128', 'U256']) {\n\t\t\texpectType('number', argVal);\n\t\t} else if (normalizedType === 'Bool') {\n\t\t\texpectType('boolean', argVal);\n\t\t} else if (normalizedType === 'Address') {\n\t\t\texpectType('string', argVal);\n\t\t\tif (argVal && !isValidSuiAddress(argVal as string)) {\n\t\t\t\tthrow new Error('Invalid Sui Address');\n\t\t\t}\n\t\t}\n\t\treturn normalizedType.toLowerCase();\n\t} else if (typeof normalizedType === 'string') {\n\t\tthrow new Error(`Unknown pure normalized type ${JSON.stringify(normalizedType, null, 2)}`);\n\t}\n\n\tif ('Vector' in normalizedType) {\n\t\tif ((argVal === undefined || typeof argVal === 'string') && normalizedType.Vector === 'U8') {\n\t\t\treturn 'string';\n\t\t}\n\n\t\tif (argVal !== undefined && !Array.isArray(argVal)) {\n\t\t\tthrow new Error(`Expect ${argVal} to be a array, received ${typeof argVal}`);\n\t\t}\n\n\t\tconst innerType = getPureSerializationType(\n\t\t\tnormalizedType.Vector,\n\t\t\t// undefined when argVal is empty\n\t\t\targVal ? argVal[0] : undefined,\n\t\t);\n\n\t\tif (innerType === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn `vector<${innerType}>`;\n\t}\n\n\tif ('Struct' in normalizedType) {\n\t\tif (isSameStruct(normalizedType.Struct, RESOLVED_ASCII_STR)) {\n\t\t\treturn 'string';\n\t\t} else if (isSameStruct(normalizedType.Struct, RESOLVED_UTF8_STR)) {\n\t\t\treturn 'utf8string';\n\t\t} else if (isSameStruct(normalizedType.Struct, RESOLVED_SUI_ID)) {\n\t\t\treturn 'address';\n\t\t} else if (isSameStruct(normalizedType.Struct, RESOLVED_STD_OPTION)) {\n\t\t\tconst optionToVec: SuiMoveNormalizedType = {\n\t\t\t\tVector: normalizedType.Struct.typeArguments[0],\n\t\t\t};\n\t\t\treturn getPureSerializationType(optionToVec, argVal);\n\t\t}\n\t}\n\n\treturn undefined;\n}\n"],"mappings":"AAIA,SAASA,gBAAA,QAAwB;AACjC,SAASC,mBAAA,EAAqBC,qBAAA,QAA6B;AAC3D,SAASC,iBAAA,QAAyB;AAElC,MAAMC,kBAAA,GAAqB;AAC3B,MAAMC,cAAA,GAAiB;AAEvB,MAAMC,qBAAA,GAAwB;AAC9B,MAAMC,qBAAA,GAAwB;AAE9B,MAAMC,oBAAA,GAAuB;AAC7B,MAAMC,oBAAA,GAAuB;AAE7B,MAAMC,sBAAA,GAAyB;AAC/B,MAAMC,sBAAA,GAAyB;AAE/B,MAAMC,eAAA,GAAkB;EACvBC,OAAA,EAASX,qBAAA;EACTY,MAAA,EAAQV,kBAAA;EACRW,IAAA,EAAMV;AACP;AACA,MAAMW,kBAAA,GAAqB;EAC1BH,OAAA,EAASZ,mBAAA;EACTa,MAAA,EAAQR,qBAAA;EACRS,IAAA,EAAMR;AACP;AACA,MAAMU,iBAAA,GAAoB;EACzBJ,OAAA,EAASZ,mBAAA;EACTa,MAAA,EAAQN,oBAAA;EACRO,IAAA,EAAMN;AACP;AAEA,MAAMS,mBAAA,GAAsB;EAC3BL,OAAA,EAASZ,mBAAA;EACTa,MAAA,EAAQJ,sBAAA;EACRK,IAAA,EAAMJ;AACP;AAEA,MAAMQ,YAAA,GAAeA,CAACC,CAAA,EAAQC,CAAA,KAC7BD,CAAA,CAAEP,OAAA,KAAYQ,CAAA,CAAER,OAAA,IAAWO,CAAA,CAAEN,MAAA,KAAWO,CAAA,CAAEP,MAAA,IAAUM,CAAA,CAAEL,IAAA,KAASM,CAAA,CAAEN,IAAA;AAE3D,SAASO,YAAYC,KAAA,EAAuC;EAClE,MAAMC,MAAA,GAASxB,gBAAA,CAAiBuB,KAAK,GAAGE,MAAA;EACxC,OACCD,MAAA,EAAQX,OAAA,KAAY,SAASW,MAAA,EAAQV,MAAA,KAAW,gBAAgBU,MAAA,EAAQT,IAAA,KAAS;AAEnF;AAEA,SAASW,WAAWC,QAAA,EAAkBC,MAAA,EAAuB;EAC5D,IAAI,OAAOA,MAAA,KAAW,aAAa;IAClC;EACD;EACA,IAAI,OAAOA,MAAA,KAAWD,QAAA,EAAU;IAC/B,MAAM,IAAIE,KAAA,CAAM,UAAUD,MAAA,UAAgBD,QAAA,cAAsB,OAAOC,MAAA,EAAQ;EAChF;AACD;AAEA,MAAME,YAAA,GAAe,CAAC,WAAW,QAAQ,MAAM,OAAO,OAAO,OAAO,QAAQ,MAAM;AAE3E,SAASC,yBACfC,cAAA,EACAJ,MAAA,EACqB;EACrB,IAAI,OAAOI,cAAA,KAAmB,YAAYF,YAAA,CAAaG,QAAA,CAASD,cAAc,GAAG;IAChF,IAAIA,cAAA,IAAkB,CAAC,MAAM,OAAO,OAAO,OAAO,QAAQ,MAAM,GAAG;MAClEN,UAAA,CAAW,UAAUE,MAAM;IAC5B,WAAWI,cAAA,KAAmB,QAAQ;MACrCN,UAAA,CAAW,WAAWE,MAAM;IAC7B,WAAWI,cAAA,KAAmB,WAAW;MACxCN,UAAA,CAAW,UAAUE,MAAM;MAC3B,IAAIA,MAAA,IAAU,CAACzB,iBAAA,CAAkByB,MAAgB,GAAG;QACnD,MAAM,IAAIC,KAAA,CAAM,qBAAqB;MACtC;IACD;IACA,OAAOG,cAAA,CAAeE,WAAA,CAAY;EACnC,WAAW,OAAOF,cAAA,KAAmB,UAAU;IAC9C,MAAM,IAAIH,KAAA,CAAM,gCAAgCM,IAAA,CAAKC,SAAA,CAAUJ,cAAA,EAAgB,MAAM,CAAC,GAAG;EAC1F;EAEA,IAAI,YAAYA,cAAA,EAAgB;IAC/B,KAAKJ,MAAA,KAAW,UAAa,OAAOA,MAAA,KAAW,aAAaI,cAAA,CAAeK,MAAA,KAAW,MAAM;MAC3F,OAAO;IACR;IAEA,IAAIT,MAAA,KAAW,UAAa,CAACU,KAAA,CAAMC,OAAA,CAAQX,MAAM,GAAG;MACnD,MAAM,IAAIC,KAAA,CAAM,UAAUD,MAAA,4BAAkC,OAAOA,MAAA,EAAQ;IAC5E;IAEA,MAAMY,SAAA,GAAYT,wBAAA,CACjBC,cAAA,CAAeK,MAAA;IAAA;IAEfT,MAAA,GAASA,MAAA,CAAO,CAAC,IAAI,MACtB;IAEA,IAAIY,SAAA,KAAc,QAAW;MAC5B;IACD;IAEA,OAAO,UAAUA,SAAA;EAClB;EAEA,IAAI,YAAYR,cAAA,EAAgB;IAC/B,IAAIb,YAAA,CAAaa,cAAA,CAAeP,MAAA,EAAQT,kBAAkB,GAAG;MAC5D,OAAO;IACR,WAAWG,YAAA,CAAaa,cAAA,CAAeP,MAAA,EAAQR,iBAAiB,GAAG;MAClE,OAAO;IACR,WAAWE,YAAA,CAAaa,cAAA,CAAeP,MAAA,EAAQb,eAAe,GAAG;MAChE,OAAO;IACR,WAAWO,YAAA,CAAaa,cAAA,CAAeP,MAAA,EAAQP,mBAAmB,GAAG;MACpE,MAAMuB,WAAA,GAAqC;QAC1CJ,MAAA,EAAQL,cAAA,CAAeP,MAAA,CAAOiB,aAAA,CAAc,CAAC;MAC9C;MACA,OAAOX,wBAAA,CAAyBU,WAAA,EAAab,MAAM;IACpD;EACD;EAEA,OAAO;AACR","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}