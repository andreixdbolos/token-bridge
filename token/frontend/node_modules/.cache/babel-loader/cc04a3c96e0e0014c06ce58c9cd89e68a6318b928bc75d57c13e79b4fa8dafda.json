{"ast":null,"code":"import { toB64 } from \"@mysten/bcs\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport { bytesToHex } from \"@noble/hashes/utils\";\nimport { bcs } from \"../bcs/index.js\";\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from \"../utils/sui-types.js\";\nimport { IntentScope, messageWithIntent } from \"./intent.js\";\nfunction bytesEqual(a, b) {\n  if (a === b) return true;\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nclass PublicKey {\n  /**\n   * Checks if two public keys are equal\n   */\n  equals(publicKey) {\n    return bytesEqual(this.toRawBytes(), publicKey.toRawBytes());\n  }\n  /**\n   * Return the base-64 representation of the public key\n   */\n  toBase64() {\n    return toB64(this.toRawBytes());\n  }\n  toString() {\n    throw new Error(\"`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead.\");\n  }\n  /**\n   * Return the Sui representation of the public key encoded in\n   * base-64. A Sui public key is formed by the concatenation\n   * of the scheme flag with the raw bytes of the public key\n   */\n  toSuiPublicKey() {\n    const bytes = this.toSuiBytes();\n    return toB64(bytes);\n  }\n  verifyWithIntent(bytes, signature, intent) {\n    const intentMessage = messageWithIntent(intent, bytes);\n    const digest = blake2b(intentMessage, {\n      dkLen: 32\n    });\n    return this.verify(digest, signature);\n  }\n  /**\n   * Verifies that the signature is valid for for the provided PersonalMessage\n   */\n  verifyPersonalMessage(message, signature) {\n    return this.verifyWithIntent(bcs.vector(bcs.u8()).serialize(message).toBytes(), signature, IntentScope.PersonalMessage);\n  }\n  /**\n   * Verifies that the signature is valid for for the provided TransactionBlock\n   */\n  verifyTransactionBlock(transactionBlock, signature) {\n    return this.verifyWithIntent(transactionBlock, signature, IntentScope.TransactionData);\n  }\n  /**\n   * Returns the bytes representation of the public key\n   * prefixed with the signature scheme flag\n   */\n  toSuiBytes() {\n    const rawBytes = this.toRawBytes();\n    const suiBytes = new Uint8Array(rawBytes.length + 1);\n    suiBytes.set([this.flag()]);\n    suiBytes.set(rawBytes, 1);\n    return suiBytes;\n  }\n  /**\n   * Return the Sui address associated with this Ed25519 public key\n   */\n  toSuiAddress() {\n    return normalizeSuiAddress(bytesToHex(blake2b(this.toSuiBytes(), {\n      dkLen: 32\n    })).slice(0, SUI_ADDRESS_LENGTH * 2));\n  }\n}\nexport { PublicKey, bytesEqual };","map":{"version":3,"names":["toB64","blake2b","bytesToHex","bcs","normalizeSuiAddress","SUI_ADDRESS_LENGTH","IntentScope","messageWithIntent","bytesEqual","a","b","length","i","PublicKey","equals","publicKey","toRawBytes","toBase64","toString","Error","toSuiPublicKey","bytes","toSuiBytes","verifyWithIntent","signature","intent","intentMessage","digest","dkLen","verify","verifyPersonalMessage","message","vector","u8","serialize","toBytes","PersonalMessage","verifyTransactionBlock","transactionBlock","TransactionData","rawBytes","suiBytes","Uint8Array","set","flag","toSuiAddress","slice"],"sources":["/home/andrei/proiect-itb/token/frontend/node_modules/@mysten/sui.js/src/cryptography/publickey.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB64 } from '@mysten/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { bytesToHex } from '@noble/hashes/utils';\n\nimport { bcs } from '../bcs/index.js';\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport type { SerializedSignature } from './index.js';\nimport { IntentScope, messageWithIntent } from './intent.js';\n\n/**\n * Value to be converted into public key.\n */\nexport type PublicKeyInitData = string | Uint8Array | Iterable<number>;\n\nexport function bytesEqual(a: Uint8Array, b: Uint8Array) {\n\tif (a === b) return true;\n\n\tif (a.length !== b.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0; i < a.length; i++) {\n\t\tif (a[i] !== b[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * A public key\n */\nexport abstract class PublicKey {\n\t/**\n\t * Checks if two public keys are equal\n\t */\n\tequals(publicKey: PublicKey) {\n\t\treturn bytesEqual(this.toRawBytes(), publicKey.toRawBytes());\n\t}\n\n\t/**\n\t * Return the base-64 representation of the public key\n\t */\n\ttoBase64() {\n\t\treturn toB64(this.toRawBytes());\n\t}\n\n\ttoString(): never {\n\t\tthrow new Error(\n\t\t\t'`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead.',\n\t\t);\n\t}\n\n\t/**\n\t * Return the Sui representation of the public key encoded in\n\t * base-64. A Sui public key is formed by the concatenation\n\t * of the scheme flag with the raw bytes of the public key\n\t */\n\ttoSuiPublicKey(): string {\n\t\tconst bytes = this.toSuiBytes();\n\t\treturn toB64(bytes);\n\t}\n\n\tverifyWithIntent(\n\t\tbytes: Uint8Array,\n\t\tsignature: Uint8Array | SerializedSignature,\n\t\tintent: IntentScope,\n\t): Promise<boolean> {\n\t\tconst intentMessage = messageWithIntent(intent, bytes);\n\t\tconst digest = blake2b(intentMessage, { dkLen: 32 });\n\n\t\treturn this.verify(digest, signature);\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided PersonalMessage\n\t */\n\tverifyPersonalMessage(\n\t\tmessage: Uint8Array,\n\t\tsignature: Uint8Array | SerializedSignature,\n\t): Promise<boolean> {\n\t\treturn this.verifyWithIntent(\n\t\t\tbcs.vector(bcs.u8()).serialize(message).toBytes(),\n\t\t\tsignature,\n\t\t\tIntentScope.PersonalMessage,\n\t\t);\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided TransactionBlock\n\t */\n\tverifyTransactionBlock(\n\t\ttransactionBlock: Uint8Array,\n\t\tsignature: Uint8Array | SerializedSignature,\n\t): Promise<boolean> {\n\t\treturn this.verifyWithIntent(transactionBlock, signature, IntentScope.TransactionData);\n\t}\n\n\t/**\n\t * Returns the bytes representation of the public key\n\t * prefixed with the signature scheme flag\n\t */\n\ttoSuiBytes(): Uint8Array {\n\t\tconst rawBytes = this.toRawBytes();\n\t\tconst suiBytes = new Uint8Array(rawBytes.length + 1);\n\t\tsuiBytes.set([this.flag()]);\n\t\tsuiBytes.set(rawBytes, 1);\n\n\t\treturn suiBytes;\n\t}\n\n\t/**\n\t * Return the Sui address associated with this Ed25519 public key\n\t */\n\ttoSuiAddress(): string {\n\t\t// Each hex char represents half a byte, hence hex address doubles the length\n\t\treturn normalizeSuiAddress(\n\t\t\tbytesToHex(blake2b(this.toSuiBytes(), { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH * 2),\n\t\t);\n\t}\n\n\t/**\n\t * Return the byte array representation of the public key\n\t */\n\tabstract toRawBytes(): Uint8Array;\n\n\t/**\n\t * Return signature scheme flag of the public key\n\t */\n\tabstract flag(): number;\n\n\t/**\n\t * Verifies that the signature is valid for for the provided message\n\t */\n\tabstract verify(data: Uint8Array, signature: Uint8Array | SerializedSignature): Promise<boolean>;\n}\n"],"mappings":"AAGA,SAASA,KAAA,QAAa;AACtB,SAASC,OAAA,QAAe;AACxB,SAASC,UAAA,QAAkB;AAE3B,SAASC,GAAA,QAAW;AACpB,SAASC,mBAAA,EAAqBC,kBAAA,QAA0B;AAExD,SAASC,WAAA,EAAaC,iBAAA,QAAyB;AAOxC,SAASC,WAAWC,CAAA,EAAeC,CAAA,EAAe;EACxD,IAAID,CAAA,KAAMC,CAAA,EAAG,OAAO;EAEpB,IAAID,CAAA,CAAEE,MAAA,KAAWD,CAAA,CAAEC,MAAA,EAAQ;IAC1B,OAAO;EACR;EAEA,SAASC,CAAA,GAAI,GAAGA,CAAA,GAAIH,CAAA,CAAEE,MAAA,EAAQC,CAAA,IAAK;IAClC,IAAIH,CAAA,CAAEG,CAAC,MAAMF,CAAA,CAAEE,CAAC,GAAG;MAClB,OAAO;IACR;EACD;EACA,OAAO;AACR;AAKO,MAAeC,SAAA,CAAU;EAAA;AAAA;AAAA;EAI/BC,OAAOC,SAAA,EAAsB;IAC5B,OAAOP,UAAA,CAAW,KAAKQ,UAAA,CAAW,GAAGD,SAAA,CAAUC,UAAA,CAAW,CAAC;EAC5D;EAAA;AAAA;AAAA;EAKAC,SAAA,EAAW;IACV,OAAOjB,KAAA,CAAM,KAAKgB,UAAA,CAAW,CAAC;EAC/B;EAEAE,SAAA,EAAkB;IACjB,MAAM,IAAIC,KAAA,CACT,2FACD;EACD;EAAA;AAAA;AAAA;AAAA;AAAA;EAOAC,eAAA,EAAyB;IACxB,MAAMC,KAAA,GAAQ,KAAKC,UAAA,CAAW;IAC9B,OAAOtB,KAAA,CAAMqB,KAAK;EACnB;EAEAE,iBACCF,KAAA,EACAG,SAAA,EACAC,MAAA,EACmB;IACnB,MAAMC,aAAA,GAAgBnB,iBAAA,CAAkBkB,MAAA,EAAQJ,KAAK;IACrD,MAAMM,MAAA,GAAS1B,OAAA,CAAQyB,aAAA,EAAe;MAAEE,KAAA,EAAO;IAAG,CAAC;IAEnD,OAAO,KAAKC,MAAA,CAAOF,MAAA,EAAQH,SAAS;EACrC;EAAA;AAAA;AAAA;EAKAM,sBACCC,OAAA,EACAP,SAAA,EACmB;IACnB,OAAO,KAAKD,gBAAA,CACXpB,GAAA,CAAI6B,MAAA,CAAO7B,GAAA,CAAI8B,EAAA,CAAG,CAAC,EAAEC,SAAA,CAAUH,OAAO,EAAEI,OAAA,CAAQ,GAChDX,SAAA,EACAlB,WAAA,CAAY8B,eACb;EACD;EAAA;AAAA;AAAA;EAKAC,uBACCC,gBAAA,EACAd,SAAA,EACmB;IACnB,OAAO,KAAKD,gBAAA,CAAiBe,gBAAA,EAAkBd,SAAA,EAAWlB,WAAA,CAAYiC,eAAe;EACtF;EAAA;AAAA;AAAA;AAAA;EAMAjB,WAAA,EAAyB;IACxB,MAAMkB,QAAA,GAAW,KAAKxB,UAAA,CAAW;IACjC,MAAMyB,QAAA,GAAW,IAAIC,UAAA,CAAWF,QAAA,CAAS7B,MAAA,GAAS,CAAC;IACnD8B,QAAA,CAASE,GAAA,CAAI,CAAC,KAAKC,IAAA,CAAK,CAAC,CAAC;IAC1BH,QAAA,CAASE,GAAA,CAAIH,QAAA,EAAU,CAAC;IAExB,OAAOC,QAAA;EACR;EAAA;AAAA;AAAA;EAKAI,aAAA,EAAuB;IAEtB,OAAOzC,mBAAA,CACNF,UAAA,CAAWD,OAAA,CAAQ,KAAKqB,UAAA,CAAW,GAAG;MAAEM,KAAA,EAAO;IAAG,CAAC,CAAC,EAAEkB,KAAA,CAAM,GAAGzC,kBAAA,GAAqB,CAAC,CACtF;EACD;AAgBD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}