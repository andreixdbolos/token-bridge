{"ast":null,"code":"var __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\n\n// src/b58.ts\nimport bs58 from \"bs58\";\nvar toB58 = buffer => bs58.encode(buffer);\nvar fromB58 = str => bs58.decode(str);\n\n// src/b64.ts\nfunction b64ToUint6(nChr) {\n  return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;\n}\nfunction fromB64(sBase64, nBlocksSize) {\n  var sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, \"\"),\n    nInLen = sB64Enc.length,\n    nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2,\n    taBytes = new Uint8Array(nOutLen);\n  for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {\n    nMod4 = nInIdx & 3;\n    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 6 * (3 - nMod4);\n    if (nMod4 === 3 || nInLen - nInIdx === 1) {\n      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\n        taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;\n      }\n      nUint24 = 0;\n    }\n  }\n  return taBytes;\n}\nfunction uint6ToB64(nUint6) {\n  return nUint6 < 26 ? nUint6 + 65 : nUint6 < 52 ? nUint6 + 71 : nUint6 < 62 ? nUint6 - 4 : nUint6 === 62 ? 43 : nUint6 === 63 ? 47 : 65;\n}\nfunction toB64(aBytes) {\n  var nMod3 = 2,\n    sB64Enc = \"\";\n  for (var nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {\n    nMod3 = nIdx % 3;\n    nUint24 |= aBytes[nIdx] << (16 >>> nMod3 & 24);\n    if (nMod3 === 2 || aBytes.length - nIdx === 1) {\n      sB64Enc += String.fromCodePoint(uint6ToB64(nUint24 >>> 18 & 63), uint6ToB64(nUint24 >>> 12 & 63), uint6ToB64(nUint24 >>> 6 & 63), uint6ToB64(nUint24 & 63));\n      nUint24 = 0;\n    }\n  }\n  return sB64Enc.slice(0, sB64Enc.length - 2 + nMod3) + (nMod3 === 2 ? \"\" : nMod3 === 1 ? \"=\" : \"==\");\n}\n\n// src/hex.ts\nfunction fromHEX(hexStr) {\n  const normalized = hexStr.startsWith(\"0x\") ? hexStr.slice(2) : hexStr;\n  const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;\n  const intArr = padded.match(/.{2}/g)?.map(byte => parseInt(byte, 16)) ?? [];\n  return Uint8Array.from(intArr);\n}\nfunction toHEX(bytes) {\n  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\n\n// src/uleb.ts\nfunction ulebEncode(num) {\n  let arr = [];\n  let len = 0;\n  if (num === 0) {\n    return [0];\n  }\n  while (num > 0) {\n    arr[len] = num & 127;\n    if (num >>= 7) {\n      arr[len] |= 128;\n    }\n    len += 1;\n  }\n  return arr;\n}\nfunction ulebDecode(arr) {\n  let total = 0;\n  let shift = 0;\n  let len = 0;\n  while (true) {\n    let byte = arr[len];\n    len += 1;\n    total |= (byte & 127) << shift;\n    if ((byte & 128) === 0) {\n      break;\n    }\n    shift += 7;\n  }\n  return {\n    value: total,\n    length: len\n  };\n}\n\n// src/reader.ts\nvar BcsReader = class {\n  /**\n   * @param {Uint8Array} data Data to use as a buffer.\n   */\n  constructor(data) {\n    this.bytePosition = 0;\n    this.dataView = new DataView(data.buffer);\n  }\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes) {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Read U8 value from the buffer and shift cursor by 1.\n   * @returns\n   */\n  read8() {\n    let value = this.dataView.getUint8(this.bytePosition);\n    this.shift(1);\n    return value;\n  }\n  /**\n   * Read U16 value from the buffer and shift cursor by 2.\n   * @returns\n   */\n  read16() {\n    let value = this.dataView.getUint16(this.bytePosition, true);\n    this.shift(2);\n    return value;\n  }\n  /**\n   * Read U32 value from the buffer and shift cursor by 4.\n   * @returns\n   */\n  read32() {\n    let value = this.dataView.getUint32(this.bytePosition, true);\n    this.shift(4);\n    return value;\n  }\n  /**\n   * Read U64 value from the buffer and shift cursor by 8.\n   * @returns\n   */\n  read64() {\n    let value1 = this.read32();\n    let value2 = this.read32();\n    let result = value2.toString(16) + value1.toString(16).padStart(8, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 16.\n   */\n  read128() {\n    let value1 = BigInt(this.read64());\n    let value2 = BigInt(this.read64());\n    let result = value2.toString(16) + value1.toString(16).padStart(16, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 32.\n   * @returns\n   */\n  read256() {\n    let value1 = BigInt(this.read128());\n    let value2 = BigInt(this.read128());\n    let result = value2.toString(16) + value1.toString(16).padStart(32, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read `num` number of bytes from the buffer and shift cursor by `num`.\n   * @param num Number of bytes to read.\n   */\n  readBytes(num) {\n    let start = this.bytePosition + this.dataView.byteOffset;\n    let value = new Uint8Array(this.dataView.buffer, start, num);\n    this.shift(num);\n    return value;\n  }\n  /**\n   * Read ULEB value - an integer of varying size. Used for enum indexes and\n   * vector lengths.\n   * @returns {Number} The ULEB value.\n   */\n  readULEB() {\n    let start = this.bytePosition + this.dataView.byteOffset;\n    let buffer = new Uint8Array(this.dataView.buffer, start);\n    let {\n      value,\n      length\n    } = ulebDecode(buffer);\n    this.shift(length);\n    return value;\n  }\n  /**\n   * Read a BCS vector: read a length and then apply function `cb` X times\n   * where X is the length of the vector, defined as ULEB in BCS bytes.\n   * @param cb Callback to process elements of vector.\n   * @returns {Array<Any>} Array of the resulting values, returned by callback.\n   */\n  readVec(cb) {\n    let length = this.readULEB();\n    let result = [];\n    for (let i = 0; i < length; i++) {\n      result.push(cb(this, i, length));\n    }\n    return result;\n  }\n};\n\n// src/utils.ts\nfunction encodeStr(data, encoding) {\n  switch (encoding) {\n    case \"base58\":\n      return toB58(data);\n    case \"base64\":\n      return toB64(data);\n    case \"hex\":\n      return toHEX(data);\n    default:\n      throw new Error(\"Unsupported encoding, supported values are: base64, hex\");\n  }\n}\nfunction decodeStr(data, encoding) {\n  switch (encoding) {\n    case \"base58\":\n      return fromB58(data);\n    case \"base64\":\n      return fromB64(data);\n    case \"hex\":\n      return fromHEX(data);\n    default:\n      throw new Error(\"Unsupported encoding, supported values are: base64, hex\");\n  }\n}\nfunction splitGenericParameters(str, genericSeparators = [\"<\", \">\"]) {\n  const [left, right] = genericSeparators;\n  const tok = [];\n  let word = \"\";\n  let nestedAngleBrackets = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i];\n    if (char === left) {\n      nestedAngleBrackets++;\n    }\n    if (char === right) {\n      nestedAngleBrackets--;\n    }\n    if (nestedAngleBrackets === 0 && char === \",\") {\n      tok.push(word.trim());\n      word = \"\";\n      continue;\n    }\n    word += char;\n  }\n  tok.push(word.trim());\n  return tok;\n}\n\n// src/writer.ts\nvar BcsWriter = class {\n  constructor({\n    size = 1024,\n    maxSize,\n    allocateSize = 1024\n  } = {}) {\n    this.bytePosition = 0;\n    this.size = size;\n    this.maxSize = maxSize || size;\n    this.allocateSize = allocateSize;\n    this.dataView = new DataView(new ArrayBuffer(size));\n  }\n  ensureSizeOrGrow(bytes) {\n    const requiredSize = this.bytePosition + bytes;\n    if (requiredSize > this.size) {\n      const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n      if (requiredSize > nextSize) {\n        throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`);\n      }\n      this.size = nextSize;\n      const nextBuffer = new ArrayBuffer(this.size);\n      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n      this.dataView = new DataView(nextBuffer);\n    }\n  }\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes) {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Write a U8 value into a buffer and shift cursor position by 1.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write8(value) {\n    this.ensureSizeOrGrow(1);\n    this.dataView.setUint8(this.bytePosition, Number(value));\n    return this.shift(1);\n  }\n  /**\n   * Write a U16 value into a buffer and shift cursor position by 2.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write16(value) {\n    this.ensureSizeOrGrow(2);\n    this.dataView.setUint16(this.bytePosition, Number(value), true);\n    return this.shift(2);\n  }\n  /**\n   * Write a U32 value into a buffer and shift cursor position by 4.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write32(value) {\n    this.ensureSizeOrGrow(4);\n    this.dataView.setUint32(this.bytePosition, Number(value), true);\n    return this.shift(4);\n  }\n  /**\n   * Write a U64 value into a buffer and shift cursor position by 8.\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write64(value) {\n    toLittleEndian(BigInt(value), 8).forEach(el => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a U128 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write128(value) {\n    toLittleEndian(BigInt(value), 16).forEach(el => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a U256 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write256(value) {\n    toLittleEndian(BigInt(value), 32).forEach(el => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a ULEB value into a buffer and shift cursor position by number of bytes\n   * written.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  writeULEB(value) {\n    ulebEncode(value).forEach(el => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a vector into a buffer by first writing the vector length and then calling\n   * a callback on each passed value.\n   *\n   * @param {Array<Any>} vector Array of elements to write.\n   * @param {WriteVecCb} cb Callback to call on each element of the vector.\n   * @returns {this}\n   */\n  writeVec(vector, cb) {\n    this.writeULEB(vector.length);\n    Array.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n    return this;\n  }\n  /**\n   * Adds support for iterations over the object.\n   * @returns {Uint8Array}\n   */\n  *[Symbol.iterator]() {\n    for (let i = 0; i < this.bytePosition; i++) {\n      yield this.dataView.getUint8(i);\n    }\n    return this.toBytes();\n  }\n  /**\n   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n   * @returns {Uint8Array} Resulting bcs.\n   */\n  toBytes() {\n    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n  }\n  /**\n   * Represent data as 'hex' or 'base64'\n   * @param encoding Encoding to use: 'base64' or 'hex'\n   */\n  toString(encoding) {\n    return encodeStr(this.toBytes(), encoding);\n  }\n};\nfunction toLittleEndian(bigint, size) {\n  let result = new Uint8Array(size);\n  let i = 0;\n  while (bigint > 0) {\n    result[i] = Number(bigint % BigInt(256));\n    bigint = bigint / BigInt(256);\n    i += 1;\n  }\n  return result;\n}\n\n// src/bcs-type.ts\nvar _write, _serialize;\nvar _BcsType = class _BcsType {\n  constructor(options) {\n    __privateAdd(this, _write, void 0);\n    __privateAdd(this, _serialize, void 0);\n    this.name = options.name;\n    this.read = options.read;\n    this.serializedSize = options.serializedSize ?? (() => null);\n    __privateSet(this, _write, options.write);\n    __privateSet(this, _serialize, options.serialize ?? ((value, options2) => {\n      const writer = new BcsWriter({\n        size: this.serializedSize(value) ?? void 0,\n        ...options2\n      });\n      __privateGet(this, _write).call(this, value, writer);\n      return writer.toBytes();\n    }));\n    this.validate = options.validate ?? (() => {});\n  }\n  write(value, writer) {\n    this.validate(value);\n    __privateGet(this, _write).call(this, value, writer);\n  }\n  serialize(value, options) {\n    this.validate(value);\n    return new SerializedBcs(this, __privateGet(this, _serialize).call(this, value, options));\n  }\n  parse(bytes) {\n    const reader = new BcsReader(bytes);\n    return this.read(reader);\n  }\n  transform({\n    name,\n    input,\n    output\n  }) {\n    return new _BcsType({\n      name: name ?? this.name,\n      read: reader => output(this.read(reader)),\n      write: (value, writer) => __privateGet(this, _write).call(this, input(value), writer),\n      serializedSize: value => this.serializedSize(input(value)),\n      serialize: (value, options) => __privateGet(this, _serialize).call(this, input(value), options),\n      validate: value => this.validate(input(value))\n    });\n  }\n};\n_write = new WeakMap();\n_serialize = new WeakMap();\nvar BcsType = _BcsType;\nvar SERIALIZED_BCS_BRAND = Symbol.for(\"@mysten/serialized-bcs\");\nfunction isSerializedBcs(obj) {\n  return !!obj && typeof obj === \"object\" && obj[SERIALIZED_BCS_BRAND] === true;\n}\nvar _schema, _bytes;\nvar SerializedBcs = class {\n  constructor(type, schema) {\n    __privateAdd(this, _schema, void 0);\n    __privateAdd(this, _bytes, void 0);\n    __privateSet(this, _schema, type);\n    __privateSet(this, _bytes, schema);\n  }\n  // Used to brand SerializedBcs so that they can be identified, even between multiple copies\n  // of the @mysten/bcs package are installed\n  get [SERIALIZED_BCS_BRAND]() {\n    return true;\n  }\n  toBytes() {\n    return __privateGet(this, _bytes);\n  }\n  toHex() {\n    return toHEX(__privateGet(this, _bytes));\n  }\n  toBase64() {\n    return toB64(__privateGet(this, _bytes));\n  }\n  toBase58() {\n    return toB58(__privateGet(this, _bytes));\n  }\n  parse() {\n    return __privateGet(this, _schema).parse(__privateGet(this, _bytes));\n  }\n};\n_schema = new WeakMap();\n_bytes = new WeakMap();\nfunction fixedSizeBcsType({\n  size,\n  ...options\n}) {\n  return new BcsType({\n    ...options,\n    serializedSize: () => size\n  });\n}\nfunction uIntBcsType({\n  readMethod,\n  writeMethod,\n  ...options\n}) {\n  return fixedSizeBcsType({\n    ...options,\n    read: reader => reader[readMethod](),\n    write: (value, writer) => writer[writeMethod](value),\n    validate: value => {\n      if (value < 0 || value > options.maxValue) {\n        throw new TypeError(`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`);\n      }\n      options.validate?.(value);\n    }\n  });\n}\nfunction bigUIntBcsType({\n  readMethod,\n  writeMethod,\n  ...options\n}) {\n  return fixedSizeBcsType({\n    ...options,\n    read: reader => reader[readMethod](),\n    write: (value, writer) => writer[writeMethod](BigInt(value)),\n    validate: val => {\n      const value = BigInt(val);\n      if (value < 0 || value > options.maxValue) {\n        throw new TypeError(`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`);\n      }\n      options.validate?.(value);\n    }\n  });\n}\nfunction dynamicSizeBcsType({\n  serialize,\n  ...options\n}) {\n  const type = new BcsType({\n    ...options,\n    serialize,\n    write: (value, writer) => {\n      for (const byte of type.serialize(value).toBytes()) {\n        writer.write8(byte);\n      }\n    }\n  });\n  return type;\n}\nfunction stringLikeBcsType({\n  toBytes,\n  fromBytes,\n  ...options\n}) {\n  return new BcsType({\n    ...options,\n    read: reader => {\n      const length = reader.readULEB();\n      const bytes = reader.readBytes(length);\n      return fromBytes(bytes);\n    },\n    write: (hex, writer) => {\n      const bytes = toBytes(hex);\n      writer.writeULEB(bytes.length);\n      for (let i = 0; i < bytes.length; i++) {\n        writer.write8(bytes[i]);\n      }\n    },\n    serialize: value => {\n      const bytes = toBytes(value);\n      const size = ulebEncode(bytes.length);\n      const result = new Uint8Array(size.length + bytes.length);\n      result.set(size, 0);\n      result.set(bytes, size.length);\n      return result;\n    },\n    validate: value => {\n      if (typeof value !== \"string\") {\n        throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n      }\n      options.validate?.(value);\n    }\n  });\n}\nfunction lazyBcsType(cb) {\n  let lazyType = null;\n  function getType() {\n    if (!lazyType) {\n      lazyType = cb();\n    }\n    return lazyType;\n  }\n  return new BcsType({\n    name: \"lazy\",\n    read: data => getType().read(data),\n    serializedSize: value => getType().serializedSize(value),\n    write: (value, writer) => getType().write(value, writer),\n    serialize: (value, options) => getType().serialize(value, options).toBytes()\n  });\n}\n\n// src/bcs.ts\nvar bcs = {\n  /**\n   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n   * @example\n   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n   */\n  u8(options) {\n    return uIntBcsType({\n      name: \"u8\",\n      readMethod: \"read8\",\n      writeMethod: \"write8\",\n      size: 1,\n      maxValue: 2 ** 8 - 1,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n   * @example\n   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n   */\n  u16(options) {\n    return uIntBcsType({\n      name: \"u16\",\n      readMethod: \"read16\",\n      writeMethod: \"write16\",\n      size: 2,\n      maxValue: 2 ** 16 - 1,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n   * @example\n   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n   */\n  u32(options) {\n    return uIntBcsType({\n      name: \"u32\",\n      readMethod: \"read32\",\n      writeMethod: \"write32\",\n      size: 4,\n      maxValue: 2 ** 32 - 1,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n   * @example\n   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n   */\n  u64(options) {\n    return bigUIntBcsType({\n      name: \"u64\",\n      readMethod: \"read64\",\n      writeMethod: \"write64\",\n      size: 8,\n      maxValue: 2n ** 64n - 1n,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n   * @example\n   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n   */\n  u128(options) {\n    return bigUIntBcsType({\n      name: \"u128\",\n      readMethod: \"read128\",\n      writeMethod: \"write128\",\n      size: 16,\n      maxValue: 2n ** 128n - 1n,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n   * @example\n   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n   */\n  u256(options) {\n    return bigUIntBcsType({\n      name: \"u256\",\n      readMethod: \"read256\",\n      writeMethod: \"write256\",\n      size: 32,\n      maxValue: 2n ** 256n - 1n,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write boolean values.\n   * @example\n   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n   */\n  bool(options) {\n    return fixedSizeBcsType({\n      name: \"bool\",\n      size: 1,\n      read: reader => reader.read8() === 1,\n      write: (value, writer) => writer.write8(value ? 1 : 0),\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (typeof value !== \"boolean\") {\n          throw new TypeError(`Expected boolean, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n   * @example\n   *\n   */\n  uleb128(options) {\n    return dynamicSizeBcsType({\n      name: \"uleb128\",\n      read: reader => reader.readULEB(),\n      serialize: value => {\n        return Uint8Array.from(ulebEncode(value));\n      },\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType representing a fixed length byte array\n   * @param size The number of bytes this types represents\n   * @example\n   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n   */\n  bytes(size, options) {\n    return fixedSizeBcsType({\n      name: `bytes[${size}]`,\n      size,\n      read: reader => reader.readBytes(size),\n      write: (value, writer) => {\n        for (let i = 0; i < size; i++) {\n          writer.write8(value[i] ?? 0);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (!(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== size) {\n          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n   * @example\n   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n   */\n  string(options) {\n    return stringLikeBcsType({\n      name: \"string\",\n      toBytes: value => new TextEncoder().encode(value),\n      fromBytes: bytes => new TextDecoder().decode(bytes),\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that represents a fixed length array of a given type\n   * @param size The number of elements in the array\n   * @param type The BcsType of each element in the array\n   * @example\n   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n   */\n  fixedArray(size, type, options) {\n    return new BcsType({\n      name: `${type.name}[${size}]`,\n      read: reader => {\n        const result = new Array(size);\n        for (let i = 0; i < size; i++) {\n          result[i] = type.read(reader);\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (const item of value) {\n          type.write(item, writer);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (!(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== size) {\n          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing an optional value\n   * @param type The BcsType of the optional value\n   * @example\n   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n   */\n  option(type) {\n    return bcs.enum(`Option<${type.name}>`, {\n      None: null,\n      Some: type\n    }).transform({\n      input: value => {\n        if (value == null) {\n          return {\n            None: true\n          };\n        }\n        return {\n          Some: value\n        };\n      },\n      output: value => {\n        if (\"Some\" in value) {\n          return value.Some;\n        }\n        return null;\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a variable length vector of a given type\n   * @param type The BcsType of each element in the vector\n   *\n   * @example\n   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n   */\n  vector(type, options) {\n    return new BcsType({\n      name: `vector<${type.name}>`,\n      read: reader => {\n        const length = reader.readULEB();\n        const result = new Array(length);\n        for (let i = 0; i < length; i++) {\n          result[i] = type.read(reader);\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        writer.writeULEB(value.length);\n        for (const item of value) {\n          type.write(item, writer);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (!(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a tuple of a given set of types\n   * @param types The BcsTypes for each element in the tuple\n   *\n   * @example\n   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n   */\n  tuple(types, options) {\n    return new BcsType({\n      name: `(${types.map(t => t.name).join(\", \")})`,\n      serializedSize: values => {\n        let total = 0;\n        for (let i = 0; i < types.length; i++) {\n          const size = types[i].serializedSize(values[i]);\n          if (size == null) {\n            return null;\n          }\n          total += size;\n        }\n        return total;\n      },\n      read: reader => {\n        const result = [];\n        for (const type of types) {\n          result.push(type.read(reader));\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (let i = 0; i < types.length; i++) {\n          types[i].write(value[i], writer);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (!Array.isArray(value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== types.length) {\n          throw new TypeError(`Expected array of length ${types.length}, found ${value.length}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a struct of a given set of fields\n   * @param name The name of the struct\n   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n   *\n   * @example\n   * const struct = bcs.struct('MyStruct', {\n   *  a: bcs.u8(),\n   *  b: bcs.string(),\n   * })\n   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n   */\n  struct(name, fields, options) {\n    const canonicalOrder = Object.entries(fields);\n    return new BcsType({\n      name,\n      serializedSize: values => {\n        let total = 0;\n        for (const [field, type] of canonicalOrder) {\n          const size = type.serializedSize(values[field]);\n          if (size == null) {\n            return null;\n          }\n          total += size;\n        }\n        return total;\n      },\n      read: reader => {\n        const result = {};\n        for (const [field, type] of canonicalOrder) {\n          result[field] = type.read(reader);\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (const [field, type] of canonicalOrder) {\n          type.write(value[field], writer);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (typeof value !== \"object\" || value == null) {\n          throw new TypeError(`Expected object, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing an enum of a given set of options\n   * @param name The name of the enum\n   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n   * null can be used to represent a variant with no data.\n   *\n   * @example\n   * const enum = bcs.enum('MyEnum', {\n   *   A: bcs.u8(),\n   *   B: bcs.string(),\n   *   C: null,\n   * })\n   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n   */\n  enum(name, values, options) {\n    const canonicalOrder = Object.entries(values);\n    return new BcsType({\n      name,\n      read: reader => {\n        const index = reader.readULEB();\n        const [name2, type] = canonicalOrder[index];\n        return {\n          [name2]: type?.read(reader) ?? true\n        };\n      },\n      write: (value, writer) => {\n        const [name2, val] = Object.entries(value)[0];\n        for (let i = 0; i < canonicalOrder.length; i++) {\n          const [optionName, optionType] = canonicalOrder[i];\n          if (optionName === name2) {\n            writer.writeULEB(i);\n            optionType?.write(val, writer);\n            return;\n          }\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (typeof value !== \"object\" || value == null) {\n          throw new TypeError(`Expected object, found ${typeof value}`);\n        }\n        const keys = Object.keys(value);\n        if (keys.length !== 1) {\n          throw new TypeError(`Expected object with one key, found ${keys.length}`);\n        }\n        const [name2] = keys;\n        if (!Object.hasOwn(values, name2)) {\n          throw new TypeError(`Invalid enum variant ${name2}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a map of a given key and value type\n   * @param keyType The BcsType of the key\n   * @param valueType The BcsType of the value\n   * @example\n   * const map = bcs.map(bcs.u8(), bcs.string())\n   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n   */\n  map(keyType, valueType) {\n    return bcs.vector(bcs.tuple([keyType, valueType])).transform({\n      name: `Map<${keyType.name}, ${valueType.name}>`,\n      input: value => {\n        return [...value.entries()];\n      },\n      output: value => {\n        const result = /* @__PURE__ */new Map();\n        for (const [key, val] of value) {\n          result.set(key, val);\n        }\n        return result;\n      }\n    });\n  },\n  /**\n   * @deprecated\n   *\n   * Generics should be implemented as generic typescript functions instead:\n   *\n   * ```ts\n   * function VecMap<K, V>, (K: BcsType<K>, V: BcsType<V>) {\n   *   return bcs.struct('VecMap<K, V>', {\n   *     keys: bcs.vector(K),\n   *     values: bcs.vector(V),\n   *   })\n   * }\n   * ```\n   */\n  generic(names, cb) {\n    return (...types) => {\n      return cb(...types).transform({\n        name: `${cb.name}<${types.map(t => t.name).join(\", \")}>`,\n        input: value => value,\n        output: value => value\n      });\n    };\n  },\n  /**\n   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n   * @param cb A callback that returns the BcsType\n   */\n  lazy(cb) {\n    return lazyBcsType(cb);\n  }\n};\n\n// src/legacy-registry.ts\nvar SUI_ADDRESS_LENGTH = 32;\nvar _BCS = class _BCS {\n  /**\n   * Construct a BCS instance with a prepared schema.\n   *\n   * @param schema A prepared schema with type definitions\n   * @param withPrimitives Whether to register primitive types by default\n   */\n  constructor(schema) {\n    /**\n     * Map of kind `TypeName => TypeInterface`. Holds all\n     * callbacks for (de)serialization of every registered type.\n     *\n     * If the value stored is a string, it is treated as an alias.\n     */\n    this.types = /* @__PURE__ */new Map();\n    /**\n     * Count temp keys to generate a new one when requested.\n     */\n    this.counter = 0;\n    if (schema instanceof _BCS) {\n      this.schema = schema.schema;\n      this.types = new Map(schema.types);\n      return;\n    }\n    this.schema = schema;\n    this.registerAddressType(_BCS.ADDRESS, schema.addressLength, schema.addressEncoding);\n    this.registerVectorType(schema.vectorType);\n    if (schema.types && schema.types.structs) {\n      for (let name of Object.keys(schema.types.structs)) {\n        this.registerStructType(name, schema.types.structs[name]);\n      }\n    }\n    if (schema.types && schema.types.enums) {\n      for (let name of Object.keys(schema.types.enums)) {\n        this.registerEnumType(name, schema.types.enums[name]);\n      }\n    }\n    if (schema.types && schema.types.aliases) {\n      for (let name of Object.keys(schema.types.aliases)) {\n        this.registerAlias(name, schema.types.aliases[name]);\n      }\n    }\n    if (schema.withPrimitives !== false) {\n      registerPrimitives(this);\n    }\n  }\n  /**\n   * Name of the key to use for temporary struct definitions.\n   * Returns a temp key + index (for a case when multiple temp\n   * structs are processed).\n   */\n  tempKey() {\n    return `bcs-struct-${++this.counter}`;\n  }\n  /**\n   * Serialize data into bcs.\n   *\n   * @example\n   * bcs.registerVectorType('vector<u8>', 'u8');\n   *\n   * let serialized = BCS\n   *   .set('vector<u8>', [1,2,3,4,5,6])\n   *   .toBytes();\n   *\n   * console.assert(toHex(serialized) === '06010203040506');\n   *\n   * @param type Name of the type to serialize (must be registered) or a struct type.\n   * @param data Data to serialize.\n   * @param size Serialization buffer size. Default 1024 = 1KB.\n   * @return A BCS reader instance. Usually you'd want to call `.toBytes()`\n   */\n  ser(type, data, options) {\n    if (typeof type === \"string\" || Array.isArray(type)) {\n      const {\n        name,\n        params\n      } = this.parseTypeName(type);\n      return this.getTypeInterface(name).encode(this, data, options, params);\n    }\n    if (typeof type === \"object\") {\n      const key = this.tempKey();\n      const temp = new _BCS(this);\n      return temp.registerStructType(key, type).ser(key, data, options);\n    }\n    throw new Error(`Incorrect type passed into the '.ser()' function. \n${JSON.stringify(type)}`);\n  }\n  /**\n   * Deserialize BCS into a JS type.\n   *\n   * @example\n   * let num = bcs.ser('u64', '4294967295').toString('hex');\n   * let deNum = bcs.de('u64', num, 'hex');\n   * console.assert(deNum.toString(10) === '4294967295');\n   *\n   * @param type Name of the type to deserialize (must be registered) or a struct type definition.\n   * @param data Data to deserialize.\n   * @param encoding Optional - encoding to use if data is of type String\n   * @return Deserialized data.\n   */\n  de(type, data, encoding) {\n    if (typeof data === \"string\") {\n      if (encoding) {\n        data = decodeStr(data, encoding);\n      } else {\n        throw new Error(\"To pass a string to `bcs.de`, specify encoding\");\n      }\n    }\n    if (typeof type === \"string\" || Array.isArray(type)) {\n      const {\n        name,\n        params\n      } = this.parseTypeName(type);\n      return this.getTypeInterface(name).decode(this, data, params);\n    }\n    if (typeof type === \"object\") {\n      const temp = new _BCS(this);\n      const key = this.tempKey();\n      return temp.registerStructType(key, type).de(key, data, encoding);\n    }\n    throw new Error(`Incorrect type passed into the '.de()' function. \n${JSON.stringify(type)}`);\n  }\n  /**\n   * Check whether a `TypeInterface` has been loaded for a `type`.\n   * @param type Name of the type to check.\n   * @returns\n   */\n  hasType(type) {\n    return this.types.has(type);\n  }\n  /**\n   * Create an alias for a type.\n   * WARNING: this can potentially lead to recursion\n   * @param name Alias to use\n   * @param forType Type to reference\n   * @returns\n   *\n   * @example\n   * ```\n   * let bcs = new BCS(getSuiMoveConfig());\n   * bcs.registerAlias('ObjectDigest', BCS.BASE58);\n   * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');\n   * ```\n   */\n  registerAlias(name, forType) {\n    this.types.set(name, forType);\n    return this;\n  }\n  /**\n   * Method to register new types for BCS internal representation.\n   * For each registered type 2 callbacks must be specified and one is optional:\n   *\n   * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;\n   * - decodeCb(reader) - write a way to deserialize data with BcsReader;\n   * - validateCb(data) - validate data - either return bool or throw an error\n   *\n   * @example\n   * // our type would be a string that consists only of numbers\n   * bcs.registerType('number_string',\n   *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),\n   *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8\n   *    (value) => /[0-9]+/.test(value) // test that it has at least one digit\n   * );\n   * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);\n   *\n   * @param name\n   * @param encodeCb Callback to encode a value.\n   * @param decodeCb Callback to decode a value.\n   * @param validateCb Optional validator Callback to check type before serialization.\n   */\n  registerType(typeName, encodeCb, decodeCb, validateCb = () => true) {\n    const {\n      name,\n      params: generics\n    } = this.parseTypeName(typeName);\n    this.types.set(name, {\n      encode(self, data, options, typeParams) {\n        const typeMap = generics.reduce((acc, value, index) => {\n          return Object.assign(acc, {\n            [value]: typeParams[index]\n          });\n        }, {});\n        return this._encodeRaw.call(self, new BcsWriter(options), data, typeParams, typeMap);\n      },\n      decode(self, data, typeParams) {\n        const typeMap = generics.reduce((acc, value, index) => {\n          return Object.assign(acc, {\n            [value]: typeParams[index]\n          });\n        }, {});\n        return this._decodeRaw.call(self, new BcsReader(data), typeParams, typeMap);\n      },\n      // these methods should always be used with caution as they require pre-defined\n      // reader and writer and mainly exist to allow multi-field (de)serialization;\n      _encodeRaw(writer, data, typeParams, typeMap) {\n        if (validateCb(data)) {\n          return encodeCb.call(this, writer, data, typeParams, typeMap);\n        } else {\n          throw new Error(`Validation failed for type ${name}, data: ${data}`);\n        }\n      },\n      _decodeRaw(reader, typeParams, typeMap) {\n        return decodeCb.call(this, reader, typeParams, typeMap);\n      }\n    });\n    return this;\n  }\n  /**\n  \t * Method to register BcsType instances to the registry\n  \t * Types are registered with a callback that provides BcsType instances for each generic\n  \t * passed to the type.\n  \t *\n  \t * - createType(...generics) - Return a BcsType instance\n  \t *\n  \t * @example\n  \t * // our type would be a string that consists only of numbers\n  \t * bcs.registerType('Box<T>', (T) => {\n  \t * \t\treturn bcs.struct({\n  \t * \t\t\tvalue: T\n  \t * \t\t});\n  \t * });\n  \n  \t * console.log(Array.from(bcs.ser('Box<string>', '12345').toBytes()) == [5,1,2,3,4,5]);\n  \t *\n  \t * @param name\n  \t * @param createType a Callback to create the BcsType with any passed in generics\n  \t */\n  registerBcsType(typeName, createType) {\n    this.registerType(typeName, (writer, data, typeParams) => {\n      const generics = typeParams.map(param => new BcsType({\n        name: String(param),\n        write: (data2, writer2) => {\n          const {\n            name,\n            params\n          } = this.parseTypeName(param);\n          const typeInterface = this.getTypeInterface(name);\n          const typeMap = params.reduce((acc, value, index) => {\n            return Object.assign(acc, {\n              [value]: typeParams[index]\n            });\n          }, {});\n          return typeInterface._encodeRaw.call(this, writer2, data2, params, typeMap);\n        },\n        read: () => {\n          throw new Error(\"Not implemented\");\n        }\n      }));\n      createType(...generics).write(data, writer);\n      return writer;\n    }, (reader, typeParams) => {\n      const generics = typeParams.map(param => new BcsType({\n        name: String(param),\n        write: (data, writer) => {\n          throw new Error(\"Not implemented\");\n        },\n        read: reader2 => {\n          const {\n            name,\n            params\n          } = this.parseTypeName(param);\n          const typeInterface = this.getTypeInterface(name);\n          const typeMap = params.reduce((acc, value, index) => {\n            return Object.assign(acc, {\n              [value]: typeParams[index]\n            });\n          }, {});\n          return typeInterface._decodeRaw.call(this, reader2, params, typeMap);\n        }\n      }));\n      return createType(...generics).read(reader);\n    });\n    return this;\n  }\n  /**\n   * Register an address type which is a sequence of U8s of specified length.\n   * @example\n   * bcs.registerAddressType('address', SUI_ADDRESS_LENGTH);\n   * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');\n   *\n   * @param name Name of the address type.\n   * @param length Byte length of the address.\n   * @param encoding Encoding to use for the address type\n   * @returns\n   */\n  registerAddressType(name, length, encoding = \"hex\") {\n    switch (encoding) {\n      case \"base64\":\n        return this.registerType(name, function encodeAddress(writer, data) {\n          return fromB64(data).reduce((writer2, el) => writer2.write8(el), writer);\n        }, function decodeAddress(reader) {\n          return toB64(reader.readBytes(length));\n        });\n      case \"hex\":\n        return this.registerType(name, function encodeAddress(writer, data) {\n          return fromHEX(data).reduce((writer2, el) => writer2.write8(el), writer);\n        }, function decodeAddress(reader) {\n          return toHEX(reader.readBytes(length));\n        });\n      default:\n        throw new Error(\"Unsupported encoding! Use either hex or base64\");\n    }\n  }\n  /**\n   * Register custom vector type inside the bcs.\n   *\n   * @example\n   * bcs.registerVectorType('vector<T>'); // generic registration\n   * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];\n   * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');\n   *\n   * @param name Name of the type to register\n   * @param elementType Optional name of the inner type of the vector\n   * @return Returns self for chaining.\n   */\n  registerVectorType(typeName) {\n    let {\n      name,\n      params\n    } = this.parseTypeName(typeName);\n    if (params.length > 1) {\n      throw new Error(\"Vector can have only one type parameter; got \" + name);\n    }\n    return this.registerType(typeName, function encodeVector(writer, data, typeParams, typeMap) {\n      return writer.writeVec(data, (writer2, el) => {\n        let elementType = typeParams[0];\n        if (!elementType) {\n          throw new Error(`Incorrect number of type parameters passed a to vector '${typeName}'`);\n        }\n        let {\n          name: name2,\n          params: params2\n        } = this.parseTypeName(elementType);\n        if (this.hasType(name2)) {\n          return this.getTypeInterface(name2)._encodeRaw.call(this, writer2, el, params2, typeMap);\n        }\n        if (!(name2 in typeMap)) {\n          throw new Error(`Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`);\n        }\n        let {\n          name: innerName,\n          params: innerParams\n        } = this.parseTypeName(typeMap[name2]);\n        return this.getTypeInterface(innerName)._encodeRaw.call(this, writer2, el, innerParams, typeMap);\n      });\n    }, function decodeVector(reader, typeParams, typeMap) {\n      return reader.readVec(reader2 => {\n        let elementType = typeParams[0];\n        if (!elementType) {\n          throw new Error(`Incorrect number of type parameters passed to a vector '${typeName}'`);\n        }\n        let {\n          name: name2,\n          params: params2\n        } = this.parseTypeName(elementType);\n        if (this.hasType(name2)) {\n          return this.getTypeInterface(name2)._decodeRaw.call(this, reader2, params2, typeMap);\n        }\n        if (!(name2 in typeMap)) {\n          throw new Error(`Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`);\n        }\n        let {\n          name: innerName,\n          params: innerParams\n        } = this.parseTypeName(typeMap[name2]);\n        return this.getTypeInterface(innerName)._decodeRaw.call(this, reader2, innerParams, typeMap);\n      });\n    });\n  }\n  /**\n   * Safe method to register a custom Move struct. The first argument is a name of the\n   * struct which is only used on the FrontEnd and has no affect on serialization results,\n   * and the second is a struct description passed as an Object.\n   *\n   * The description object MUST have the same order on all of the platforms (ie in Move\n   * or in Rust).\n   *\n   * @example\n   * // Move / Rust struct\n   * // struct Coin {\n   * //   value: u64,\n   * //   owner: vector<u8>, // name // Vec<u8> in Rust\n   * //   is_locked: bool,\n   * // }\n   *\n   * bcs.registerStructType('Coin', {\n   *   value: bcs.U64,\n   *   owner: bcs.STRING,\n   *   is_locked: bcs.BOOL\n   * });\n   *\n   * // Created in Rust with diem/bcs\n   * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';\n   * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array\n   *  128, 209, 177,   5,  96,  0,  0,\n   *    0,  14,  66, 105, 103, 32, 87,\n   *   97, 108, 108, 101, 116, 32, 71,\n   *  117, 121,   0\n   * ];\n   *\n   * // Let's encode the value as well\n   * let test_set = bcs.ser('Coin', {\n   *   owner: 'Big Wallet Guy',\n   *   value: '412412400000',\n   *   is_locked: false,\n   * });\n   *\n   * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');\n   *\n   * @param name Name of the type to register.\n   * @param fields Fields of the struct. Must be in the correct order.\n   * @return Returns BCS for chaining.\n   */\n  registerStructType(typeName, fields) {\n    for (let key in fields) {\n      let internalName = this.tempKey();\n      let value = fields[key];\n      if (!Array.isArray(value) && typeof value !== \"string\") {\n        fields[key] = internalName;\n        this.registerStructType(internalName, value);\n      }\n    }\n    let struct = Object.freeze(fields);\n    let canonicalOrder = Object.keys(struct);\n    let {\n      name: structName,\n      params: generics\n    } = this.parseTypeName(typeName);\n    return this.registerType(typeName, function encodeStruct(writer, data, typeParams, typeMap) {\n      if (!data || data.constructor !== Object) {\n        throw new Error(`Expected ${structName} to be an Object, got: ${data}`);\n      }\n      if (typeParams.length !== generics.length) {\n        throw new Error(`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`);\n      }\n      for (let key of canonicalOrder) {\n        if (!(key in data)) {\n          throw new Error(`Struct ${structName} requires field ${key}:${struct[key]}`);\n        }\n        const {\n          name: fieldType,\n          params: fieldParams\n        } = this.parseTypeName(struct[key]);\n        if (!generics.includes(fieldType)) {\n          this.getTypeInterface(fieldType)._encodeRaw.call(this, writer, data[key], fieldParams, typeMap);\n        } else {\n          const paramIdx = generics.indexOf(fieldType);\n          let {\n            name,\n            params\n          } = this.parseTypeName(typeParams[paramIdx]);\n          if (this.hasType(name)) {\n            this.getTypeInterface(name)._encodeRaw.call(this, writer, data[key], params, typeMap);\n            continue;\n          }\n          if (!(name in typeMap)) {\n            throw new Error(`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`);\n          }\n          let {\n            name: innerName,\n            params: innerParams\n          } = this.parseTypeName(typeMap[name]);\n          this.getTypeInterface(innerName)._encodeRaw.call(this, writer, data[key], innerParams, typeMap);\n        }\n      }\n      return writer;\n    }, function decodeStruct(reader, typeParams, typeMap) {\n      if (typeParams.length !== generics.length) {\n        throw new Error(`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`);\n      }\n      let result = {};\n      for (let key of canonicalOrder) {\n        const {\n          name: fieldName,\n          params: fieldParams\n        } = this.parseTypeName(struct[key]);\n        if (!generics.includes(fieldName)) {\n          result[key] = this.getTypeInterface(fieldName)._decodeRaw.call(this, reader, fieldParams, typeMap);\n        } else {\n          const paramIdx = generics.indexOf(fieldName);\n          let {\n            name,\n            params\n          } = this.parseTypeName(typeParams[paramIdx]);\n          if (this.hasType(name)) {\n            result[key] = this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap);\n            continue;\n          }\n          if (!(name in typeMap)) {\n            throw new Error(`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`);\n          }\n          let {\n            name: innerName,\n            params: innerParams\n          } = this.parseTypeName(typeMap[name]);\n          result[key] = this.getTypeInterface(innerName)._decodeRaw.call(this, reader, innerParams, typeMap);\n        }\n      }\n      return result;\n    });\n  }\n  /**\n   * Safe method to register custom enum type where each invariant holds the value of another type.\n   * @example\n   * bcs.registerStructType('Coin', { value: 'u64' });\n   * bcs.registerEnumType('MyEnum', {\n   *  single: 'Coin',\n   *  multi: 'vector<Coin>',\n   *  empty: null\n   * });\n   *\n   * console.log(\n   *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }\n   *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }\n   * )\n   *\n   * // and serialization\n   * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();\n   * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });\n   *\n   * @param name\n   * @param variants\n   */\n  registerEnumType(typeName, variants) {\n    for (let key in variants) {\n      let internalName = this.tempKey();\n      let value = variants[key];\n      if (value !== null && !Array.isArray(value) && typeof value !== \"string\") {\n        variants[key] = internalName;\n        this.registerStructType(internalName, value);\n      }\n    }\n    let struct = Object.freeze(variants);\n    let canonicalOrder = Object.keys(struct);\n    let {\n      name,\n      params: canonicalTypeParams\n    } = this.parseTypeName(typeName);\n    return this.registerType(typeName, function encodeEnum(writer, data, typeParams, typeMap) {\n      if (!data) {\n        throw new Error(`Unable to write enum \"${name}\", missing data.\nReceived: \"${data}\"`);\n      }\n      if (typeof data !== \"object\") {\n        throw new Error(`Incorrect data passed into enum \"${name}\", expected object with properties: \"${canonicalOrder.join(\" | \")}\".\nReceived: \"${JSON.stringify(data)}\"`);\n      }\n      let key = Object.keys(data)[0];\n      if (key === void 0) {\n        throw new Error(`Empty object passed as invariant of the enum \"${name}\"`);\n      }\n      let orderByte = canonicalOrder.indexOf(key);\n      if (orderByte === -1) {\n        throw new Error(`Unknown invariant of the enum \"${name}\", allowed values: \"${canonicalOrder.join(\" | \")}\"; received \"${key}\"`);\n      }\n      let invariant = canonicalOrder[orderByte];\n      let invariantType = struct[invariant];\n      writer.write8(orderByte);\n      if (invariantType === null) {\n        return writer;\n      }\n      let paramIndex = canonicalTypeParams.indexOf(invariantType);\n      let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n      {\n        let {\n          name: name2,\n          params\n        } = this.parseTypeName(typeOrParam);\n        return this.getTypeInterface(name2)._encodeRaw.call(this, writer, data[key], params, typeMap);\n      }\n    }, function decodeEnum(reader, typeParams, typeMap) {\n      let orderByte = reader.readULEB();\n      let invariant = canonicalOrder[orderByte];\n      let invariantType = struct[invariant];\n      if (orderByte === -1) {\n        throw new Error(`Decoding type mismatch, expected enum \"${name}\" invariant index, received \"${orderByte}\"`);\n      }\n      if (invariantType === null) {\n        return {\n          [invariant]: true\n        };\n      }\n      let paramIndex = canonicalTypeParams.indexOf(invariantType);\n      let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n      {\n        let {\n          name: name2,\n          params\n        } = this.parseTypeName(typeOrParam);\n        return {\n          [invariant]: this.getTypeInterface(name2)._decodeRaw.call(this, reader, params, typeMap)\n        };\n      }\n    });\n  }\n  /**\n   * Get a set of encoders/decoders for specific type.\n   * Mainly used to define custom type de/serialization logic.\n   *\n   * @param type\n   * @returns {TypeInterface}\n   */\n  getTypeInterface(type) {\n    let typeInterface = this.types.get(type);\n    if (typeof typeInterface === \"string\") {\n      let chain = [];\n      while (typeof typeInterface === \"string\") {\n        if (chain.includes(typeInterface)) {\n          throw new Error(`Recursive definition found: ${chain.join(\" -> \")} -> ${typeInterface}`);\n        }\n        chain.push(typeInterface);\n        typeInterface = this.types.get(typeInterface);\n      }\n    }\n    if (typeInterface === void 0) {\n      throw new Error(`Type ${type} is not registered`);\n    }\n    return typeInterface;\n  }\n  /**\n   * Parse a type name and get the type's generics.\n   * @example\n   * let { typeName, typeParams } = parseTypeName('Option<Coin<SUI>>');\n   * // typeName: Option\n   * // typeParams: [ 'Coin<SUI>' ]\n   *\n   * @param name Name of the type to process\n   * @returns Object with typeName and typeParams listed as Array\n   */\n  parseTypeName(name) {\n    if (Array.isArray(name)) {\n      let [typeName2, ...params2] = name;\n      return {\n        name: typeName2,\n        params: params2\n      };\n    }\n    if (typeof name !== \"string\") {\n      throw new Error(`Illegal type passed as a name of the type: ${name}`);\n    }\n    let [left, right] = this.schema.genericSeparators || [\"<\", \">\"];\n    let l_bound = name.indexOf(left);\n    let r_bound = Array.from(name).reverse().indexOf(right);\n    if (l_bound === -1 && r_bound === -1) {\n      return {\n        name,\n        params: []\n      };\n    }\n    if (l_bound === -1 || r_bound === -1) {\n      throw new Error(`Unclosed generic in name '${name}'`);\n    }\n    let typeName = name.slice(0, l_bound);\n    let params = splitGenericParameters(name.slice(l_bound + 1, name.length - r_bound - 1), this.schema.genericSeparators);\n    return {\n      name: typeName,\n      params\n    };\n  }\n};\n// Predefined types constants\n_BCS.U8 = \"u8\";\n_BCS.U16 = \"u16\";\n_BCS.U32 = \"u32\";\n_BCS.U64 = \"u64\";\n_BCS.U128 = \"u128\";\n_BCS.U256 = \"u256\";\n_BCS.BOOL = \"bool\";\n_BCS.VECTOR = \"vector\";\n_BCS.ADDRESS = \"address\";\n_BCS.STRING = \"string\";\n_BCS.HEX = \"hex-string\";\n_BCS.BASE58 = \"base58-string\";\n_BCS.BASE64 = \"base64-string\";\nvar BCS = _BCS;\nfunction registerPrimitives(bcs2) {\n  bcs2.registerType(BCS.U8, function (writer, data) {\n    return writer.write8(data);\n  }, function (reader) {\n    return reader.read8();\n  }, u8 => u8 < 256);\n  bcs2.registerType(BCS.U16, function (writer, data) {\n    return writer.write16(data);\n  }, function (reader) {\n    return reader.read16();\n  }, u16 => u16 < 65536);\n  bcs2.registerType(BCS.U32, function (writer, data) {\n    return writer.write32(data);\n  }, function (reader) {\n    return reader.read32();\n  }, u32 => u32 <= 4294967296n);\n  bcs2.registerType(BCS.U64, function (writer, data) {\n    return writer.write64(data);\n  }, function (reader) {\n    return reader.read64();\n  });\n  bcs2.registerType(BCS.U128, function (writer, data) {\n    return writer.write128(data);\n  }, function (reader) {\n    return reader.read128();\n  });\n  bcs2.registerType(BCS.U256, function (writer, data) {\n    return writer.write256(data);\n  }, function (reader) {\n    return reader.read256();\n  });\n  bcs2.registerType(BCS.BOOL, function (writer, data) {\n    return writer.write8(data);\n  }, function (reader) {\n    return reader.read8().toString(10) === \"1\";\n  });\n  bcs2.registerType(BCS.STRING, function (writer, data) {\n    return writer.writeVec(Array.from(data), (writer2, el) => writer2.write8(el.charCodeAt(0)));\n  }, function (reader) {\n    return reader.readVec(reader2 => reader2.read8()).map(el => String.fromCharCode(Number(el))).join(\"\");\n  }, _str => true);\n  bcs2.registerType(BCS.HEX, function (writer, data) {\n    return writer.writeVec(Array.from(fromHEX(data)), (writer2, el) => writer2.write8(el));\n  }, function (reader) {\n    let bytes = reader.readVec(reader2 => reader2.read8());\n    return toHEX(new Uint8Array(bytes));\n  });\n  bcs2.registerType(BCS.BASE58, function (writer, data) {\n    return writer.writeVec(Array.from(fromB58(data)), (writer2, el) => writer2.write8(el));\n  }, function (reader) {\n    let bytes = reader.readVec(reader2 => reader2.read8());\n    return toB58(new Uint8Array(bytes));\n  });\n  bcs2.registerType(BCS.BASE64, function (writer, data) {\n    return writer.writeVec(Array.from(fromB64(data)), (writer2, el) => writer2.write8(el));\n  }, function (reader) {\n    let bytes = reader.readVec(reader2 => reader2.read8());\n    return toB64(new Uint8Array(bytes));\n  });\n}\nfunction getRustConfig() {\n  return {\n    genericSeparators: [\"<\", \">\"],\n    vectorType: \"Vec\",\n    addressLength: SUI_ADDRESS_LENGTH,\n    addressEncoding: \"hex\"\n  };\n}\nfunction getSuiMoveConfig() {\n  return {\n    genericSeparators: [\"<\", \">\"],\n    vectorType: \"vector\",\n    addressLength: SUI_ADDRESS_LENGTH,\n    addressEncoding: \"hex\"\n  };\n}\nexport { BCS, BcsReader, BcsType, BcsWriter, SerializedBcs, bcs, decodeStr, encodeStr, fromB58, fromB64, fromHEX, getRustConfig, getSuiMoveConfig, isSerializedBcs, registerPrimitives, splitGenericParameters, toB58, toB64, toHEX };","map":{"version":3,"names":["bs58","toB58","buffer","encode","fromB58","str","decode","b64ToUint6","nChr","fromB64","sBase64","nBlocksSize","sB64Enc","replace","nInLen","length","nOutLen","Math","ceil","taBytes","Uint8Array","nMod3","nMod4","nUint24","nOutIdx","nInIdx","charCodeAt","uint6ToB64","nUint6","toB64","aBytes","nLen","nIdx","String","fromCodePoint","slice","fromHEX","hexStr","normalized","startsWith","padded","intArr","match","map","byte","parseInt","from","toHEX","bytes","reduce","toString","padStart","ulebEncode","num","arr","len","ulebDecode","total","shift","value","BcsReader","constructor","data","bytePosition","dataView","DataView","read8","getUint8","read16","getUint16","read32","getUint32","read64","value1","value2","result","BigInt","read128","read256","readBytes","start","byteOffset","readULEB","readVec","cb","i","push","encodeStr","encoding","Error","decodeStr","splitGenericParameters","genericSeparators","left","right","tok","word","nestedAngleBrackets","char","trim","BcsWriter","size","maxSize","allocateSize","ArrayBuffer","ensureSizeOrGrow","requiredSize","nextSize","min","nextBuffer","set","write8","setUint8","Number","write16","setUint16","write32","setUint32","write64","toLittleEndian","forEach","el","write128","write256","writeULEB","writeVec","vector","Array","Symbol","iterator","toBytes","bigint","_write","_serialize","_BcsType","options","__privateAdd","name","read","serializedSize","__privateSet","write","serialize","options2","writer","__privateGet","call","validate","SerializedBcs","parse","reader","transform","input","output","WeakMap","BcsType","SERIALIZED_BCS_BRAND","for","isSerializedBcs","obj","_schema","_bytes","type","schema","toHex","toBase64","toBase58","fixedSizeBcsType","uIntBcsType","readMethod","writeMethod","maxValue","TypeError","bigUIntBcsType","val","dynamicSizeBcsType","stringLikeBcsType","fromBytes","hex","lazyBcsType","lazyType","getType","bcs","u8","u16","u32","u64","u128","u256","bool","uleb128","string","TextEncoder","TextDecoder","fixedArray","item","option","enum","None","Some","tuple","types","t","join","values","isArray","struct","fields","canonicalOrder","Object","entries","field","index","name2","optionName","optionType","keys","hasOwn","keyType","valueType","Map","key","generic","names","lazy","SUI_ADDRESS_LENGTH","_BCS","counter","registerAddressType","ADDRESS","addressLength","addressEncoding","registerVectorType","vectorType","structs","registerStructType","enums","registerEnumType","aliases","registerAlias","withPrimitives","registerPrimitives","tempKey","ser","params","parseTypeName","getTypeInterface","temp","JSON","stringify","de","hasType","has","forType","registerType","typeName","encodeCb","decodeCb","validateCb","generics","self","typeParams","typeMap","acc","assign","_encodeRaw","_decodeRaw","registerBcsType","createType","param","data2","writer2","typeInterface","reader2","encodeAddress","decodeAddress","encodeVector","elementType","params2","innerName","innerParams","decodeVector","internalName","freeze","structName","encodeStruct","fieldType","fieldParams","includes","paramIdx","indexOf","decodeStruct","fieldName","variants","canonicalTypeParams","encodeEnum","orderByte","invariant","invariantType","paramIndex","typeOrParam","decodeEnum","get","chain","typeName2","l_bound","r_bound","reverse","U8","U16","U32","U64","U128","U256","BOOL","VECTOR","STRING","HEX","BASE58","BASE64","BCS","bcs2","fromCharCode","_str","getRustConfig","getSuiMoveConfig"],"sources":["/home/andrei/proiect-itb/token/frontend/node_modules/@mysten/bcs/src/b58.ts","/home/andrei/proiect-itb/token/frontend/node_modules/@mysten/bcs/src/b64.ts","/home/andrei/proiect-itb/token/frontend/node_modules/@mysten/bcs/src/hex.ts","/home/andrei/proiect-itb/token/frontend/node_modules/@mysten/bcs/src/uleb.ts","/home/andrei/proiect-itb/token/frontend/node_modules/@mysten/bcs/src/reader.ts","/home/andrei/proiect-itb/token/frontend/node_modules/@mysten/bcs/src/utils.ts","/home/andrei/proiect-itb/token/frontend/node_modules/@mysten/bcs/src/writer.ts","/home/andrei/proiect-itb/token/frontend/node_modules/@mysten/bcs/src/bcs-type.ts","/home/andrei/proiect-itb/token/frontend/node_modules/@mysten/bcs/src/bcs.ts","/home/andrei/proiect-itb/token/frontend/node_modules/@mysten/bcs/src/legacy-registry.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport bs58 from 'bs58';\n\nexport const toB58 = (buffer: Uint8Array) => bs58.encode(buffer);\nexport const fromB58 = (str: string) => bs58.decode(str);\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/*\\\n|*|  Base64 / binary data / UTF-8 strings utilities\n|*|  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding\n\\*/\n\n/* Array of bytes to Base64 string decoding */\n\nfunction b64ToUint6(nChr: number) {\n\treturn nChr > 64 && nChr < 91\n\t\t? nChr - 65\n\t\t: nChr > 96 && nChr < 123\n\t\t? nChr - 71\n\t\t: nChr > 47 && nChr < 58\n\t\t? nChr + 4\n\t\t: nChr === 43\n\t\t? 62\n\t\t: nChr === 47\n\t\t? 63\n\t\t: 0;\n}\n\nexport function fromB64(sBase64: string, nBlocksSize?: number): Uint8Array {\n\tvar sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, ''),\n\t\tnInLen = sB64Enc.length,\n\t\tnOutLen = nBlocksSize\n\t\t\t? Math.ceil(((nInLen * 3 + 1) >> 2) / nBlocksSize) * nBlocksSize\n\t\t\t: (nInLen * 3 + 1) >> 2,\n\t\ttaBytes = new Uint8Array(nOutLen);\n\n\tfor (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {\n\t\tnMod4 = nInIdx & 3;\n\t\tnUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << (6 * (3 - nMod4));\n\t\tif (nMod4 === 3 || nInLen - nInIdx === 1) {\n\t\t\tfor (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\n\t\t\t\ttaBytes[nOutIdx] = (nUint24 >>> ((16 >>> nMod3) & 24)) & 255;\n\t\t\t}\n\t\t\tnUint24 = 0;\n\t\t}\n\t}\n\n\treturn taBytes;\n}\n\n/* Base64 string to array encoding */\n\nfunction uint6ToB64(nUint6: number) {\n\treturn nUint6 < 26\n\t\t? nUint6 + 65\n\t\t: nUint6 < 52\n\t\t? nUint6 + 71\n\t\t: nUint6 < 62\n\t\t? nUint6 - 4\n\t\t: nUint6 === 62\n\t\t? 43\n\t\t: nUint6 === 63\n\t\t? 47\n\t\t: 65;\n}\n\nexport function toB64(aBytes: Uint8Array): string {\n\tvar nMod3 = 2,\n\t\tsB64Enc = '';\n\n\tfor (var nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {\n\t\tnMod3 = nIdx % 3;\n\t\tnUint24 |= aBytes[nIdx] << ((16 >>> nMod3) & 24);\n\t\tif (nMod3 === 2 || aBytes.length - nIdx === 1) {\n\t\t\tsB64Enc += String.fromCodePoint(\n\t\t\t\tuint6ToB64((nUint24 >>> 18) & 63),\n\t\t\t\tuint6ToB64((nUint24 >>> 12) & 63),\n\t\t\t\tuint6ToB64((nUint24 >>> 6) & 63),\n\t\t\t\tuint6ToB64(nUint24 & 63),\n\t\t\t);\n\t\t\tnUint24 = 0;\n\t\t}\n\t}\n\n\treturn (\n\t\tsB64Enc.slice(0, sB64Enc.length - 2 + nMod3) + (nMod3 === 2 ? '' : nMod3 === 1 ? '=' : '==')\n\t);\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromHEX(hexStr: string): Uint8Array {\n\tconst normalized = hexStr.startsWith('0x') ? hexStr.slice(2) : hexStr;\n\tconst padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;\n\tconst intArr = padded.match(/.{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];\n\n\treturn Uint8Array.from(intArr);\n}\n\nexport function toHEX(bytes: Uint8Array): string {\n\treturn bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebEncode(num: number): number[] {\n\tlet arr = [];\n\tlet len = 0;\n\n\tif (num === 0) {\n\t\treturn [0];\n\t}\n\n\twhile (num > 0) {\n\t\tarr[len] = num & 0x7f;\n\t\tif ((num >>= 7)) {\n\t\t\tarr[len] |= 0x80;\n\t\t}\n\t\tlen += 1;\n\t}\n\n\treturn arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebDecode(arr: number[] | Uint8Array): {\n\tvalue: number;\n\tlength: number;\n} {\n\tlet total = 0;\n\tlet shift = 0;\n\tlet len = 0;\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tlet byte = arr[len];\n\t\tlen += 1;\n\t\ttotal |= (byte & 0x7f) << shift;\n\t\tif ((byte & 0x80) === 0) {\n\t\t\tbreak;\n\t\t}\n\t\tshift += 7;\n\t}\n\n\treturn {\n\t\tvalue: total,\n\t\tlength: len,\n\t};\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\n\t/**\n\t * @param {Uint8Array} data Data to use as a buffer.\n\t */\n\tconstructor(data: Uint8Array) {\n\t\tthis.dataView = new DataView(data.buffer);\n\t}\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number) {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Read U8 value from the buffer and shift cursor by 1.\n\t * @returns\n\t */\n\tread8(): number {\n\t\tlet value = this.dataView.getUint8(this.bytePosition);\n\t\tthis.shift(1);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U16 value from the buffer and shift cursor by 2.\n\t * @returns\n\t */\n\tread16(): number {\n\t\tlet value = this.dataView.getUint16(this.bytePosition, true);\n\t\tthis.shift(2);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U32 value from the buffer and shift cursor by 4.\n\t * @returns\n\t */\n\tread32(): number {\n\t\tlet value = this.dataView.getUint32(this.bytePosition, true);\n\t\tthis.shift(4);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U64 value from the buffer and shift cursor by 8.\n\t * @returns\n\t */\n\tread64(): string {\n\t\tlet value1 = this.read32();\n\t\tlet value2 = this.read32();\n\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 16.\n\t */\n\tread128(): string {\n\t\tlet value1 = BigInt(this.read64());\n\t\tlet value2 = BigInt(this.read64());\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 32.\n\t * @returns\n\t */\n\tread256(): string {\n\t\tlet value1 = BigInt(this.read128());\n\t\tlet value2 = BigInt(this.read128());\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read `num` number of bytes from the buffer and shift cursor by `num`.\n\t * @param num Number of bytes to read.\n\t */\n\treadBytes(num: number): Uint8Array {\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\n\t\tlet value = new Uint8Array(this.dataView.buffer, start, num);\n\n\t\tthis.shift(num);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read ULEB value - an integer of varying size. Used for enum indexes and\n\t * vector lengths.\n\t * @returns {Number} The ULEB value.\n\t */\n\treadULEB(): number {\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\n\t\tlet buffer = new Uint8Array(this.dataView.buffer, start);\n\t\tlet { value, length } = ulebDecode(buffer);\n\n\t\tthis.shift(length);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read a BCS vector: read a length and then apply function `cb` X times\n\t * where X is the length of the vector, defined as ULEB in BCS bytes.\n\t * @param cb Callback to process elements of vector.\n\t * @returns {Array<Any>} Array of the resulting values, returned by callback.\n\t */\n\treadVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n\t\tlet length = this.readULEB();\n\t\tlet result = [];\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult.push(cb(this, i, length));\n\t\t}\n\t\treturn result;\n\t}\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, toB58 } from './b58';\nimport { fromB64, toB64 } from './b64';\nimport { fromHEX, toHEX } from './hex';\nimport { Encoding } from './types';\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn toB58(data);\n\t\tcase 'base64':\n\t\t\treturn toB64(data);\n\t\tcase 'hex':\n\t\t\treturn toHEX(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn fromB58(data);\n\t\tcase 'base64':\n\t\t\treturn fromB64(data);\n\t\tcase 'hex':\n\t\t\treturn fromHEX(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\nexport function splitGenericParameters(\n\tstr: string,\n\tgenericSeparators: [string, string] = ['<', '>'],\n) {\n\tconst [left, right] = genericSeparators;\n\tconst tok = [];\n\tlet word = '';\n\tlet nestedAngleBrackets = 0;\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst char = str[i];\n\t\tif (char === left) {\n\t\t\tnestedAngleBrackets++;\n\t\t}\n\t\tif (char === right) {\n\t\t\tnestedAngleBrackets--;\n\t\t}\n\t\tif (nestedAngleBrackets === 0 && char === ',') {\n\t\t\ttok.push(word.trim());\n\t\t\tword = '';\n\t\t\tcontinue;\n\t\t}\n\t\tword += char;\n\t}\n\n\ttok.push(word.trim());\n\n\treturn tok;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Encoding } from './types';\nimport { ulebEncode } from './uleb';\nimport { encodeStr } from './utils';\n\nexport interface BcsWriterOptions {\n\t/** The initial size (in bytes) of the buffer tht will be allocated */\n\tsize?: number;\n\t/** The maximum size (in bytes) that the buffer is allowed to grow to */\n\tmaxSize?: number;\n\t/** The amount of bytes that will be allocated whenever additional memory is required */\n\tallocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\tprivate size: number;\n\tprivate maxSize: number;\n\tprivate allocateSize: number;\n\n\tconstructor({ size = 1024, maxSize, allocateSize = 1024 }: BcsWriterOptions = {}) {\n\t\tthis.size = size;\n\t\tthis.maxSize = maxSize || size;\n\t\tthis.allocateSize = allocateSize;\n\t\tthis.dataView = new DataView(new ArrayBuffer(size));\n\t}\n\n\tprivate ensureSizeOrGrow(bytes: number) {\n\t\tconst requiredSize = this.bytePosition + bytes;\n\t\tif (requiredSize > this.size) {\n\t\t\tconst nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n\t\t\tif (requiredSize > nextSize) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.size = nextSize;\n\t\t\tconst nextBuffer = new ArrayBuffer(this.size);\n\t\t\tnew Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n\t\t\tthis.dataView = new DataView(nextBuffer);\n\t\t}\n\t}\n\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number): this {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U8 value into a buffer and shift cursor position by 1.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite8(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(1);\n\t\tthis.dataView.setUint8(this.bytePosition, Number(value));\n\t\treturn this.shift(1);\n\t}\n\t/**\n\t * Write a U16 value into a buffer and shift cursor position by 2.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite16(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(2);\n\t\tthis.dataView.setUint16(this.bytePosition, Number(value), true);\n\t\treturn this.shift(2);\n\t}\n\t/**\n\t * Write a U32 value into a buffer and shift cursor position by 4.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite32(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(4);\n\t\tthis.dataView.setUint32(this.bytePosition, Number(value), true);\n\t\treturn this.shift(4);\n\t}\n\t/**\n\t * Write a U64 value into a buffer and shift cursor position by 8.\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite64(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U128 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite128(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U256 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite256(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a ULEB value into a buffer and shift cursor position by number of bytes\n\t * written.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twriteULEB(value: number): this {\n\t\tulebEncode(value).forEach((el) => this.write8(el));\n\t\treturn this;\n\t}\n\t/**\n\t * Write a vector into a buffer by first writing the vector length and then calling\n\t * a callback on each passed value.\n\t *\n\t * @param {Array<Any>} vector Array of elements to write.\n\t * @param {WriteVecCb} cb Callback to call on each element of the vector.\n\t * @returns {this}\n\t */\n\twriteVec(vector: any[], cb: (writer: BcsWriter, el: any, i: number, len: number) => void): this {\n\t\tthis.writeULEB(vector.length);\n\t\tArray.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds support for iterations over the object.\n\t * @returns {Uint8Array}\n\t */\n\t*[Symbol.iterator](): Iterator<number, Iterable<number>> {\n\t\tfor (let i = 0; i < this.bytePosition; i++) {\n\t\t\tyield this.dataView.getUint8(i);\n\t\t}\n\t\treturn this.toBytes();\n\t}\n\n\t/**\n\t * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n\t * @returns {Uint8Array} Resulting bcs.\n\t */\n\ttoBytes(): Uint8Array {\n\t\treturn new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n\t}\n\n\t/**\n\t * Represent data as 'hex' or 'base64'\n\t * @param encoding Encoding to use: 'base64' or 'hex'\n\t */\n\ttoString(encoding: Encoding): string {\n\t\treturn encodeStr(this.toBytes(), encoding);\n\t}\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n\tlet result = new Uint8Array(size);\n\tlet i = 0;\n\twhile (bigint > 0) {\n\t\tresult[i] = Number(bigint % BigInt(256));\n\t\tbigint = bigint / BigInt(256);\n\t\ti += 1;\n\t}\n\treturn result;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB58 } from './b58';\nimport { toB64 } from './b64';\nimport { toHEX } from './hex';\nimport { BcsReader } from './reader';\nimport { ulebEncode } from './uleb';\nimport { BcsWriter, BcsWriterOptions } from './writer';\n\nexport interface BcsTypeOptions<T, Input = T> {\n\tname?: string;\n\tvalidate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T> {\n\t$inferType!: T;\n\t$inferInput!: Input;\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n\tvalidate: (value: Input) => void;\n\t#write: (value: Input, writer: BcsWriter) => void;\n\t#serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\n\tconstructor(\n\t\toptions: {\n\t\t\tname: string;\n\t\t\tread: (reader: BcsReader) => T;\n\t\t\twrite: (value: Input, writer: BcsWriter) => void;\n\t\t\tserialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\t\t\tserializedSize?: (value: Input) => number | null;\n\t\t\tvalidate?: (value: Input) => void;\n\t\t} & BcsTypeOptions<T, Input>,\n\t) {\n\t\tthis.name = options.name;\n\t\tthis.read = options.read;\n\t\tthis.serializedSize = options.serializedSize ?? (() => null);\n\t\tthis.#write = options.write;\n\t\tthis.#serialize =\n\t\t\toptions.serialize ??\n\t\t\t((value, options) => {\n\t\t\t\tconst writer = new BcsWriter({ size: this.serializedSize(value) ?? undefined, ...options });\n\t\t\t\tthis.#write(value, writer);\n\t\t\t\treturn writer.toBytes();\n\t\t\t});\n\n\t\tthis.validate = options.validate ?? (() => {});\n\t}\n\n\twrite(value: Input, writer: BcsWriter) {\n\t\tthis.validate(value);\n\t\tthis.#write(value, writer);\n\t}\n\n\tserialize(value: Input, options?: BcsWriterOptions) {\n\t\tthis.validate(value);\n\t\treturn new SerializedBcs(this, this.#serialize(value, options));\n\t}\n\n\tparse(bytes: Uint8Array): T {\n\t\tconst reader = new BcsReader(bytes);\n\t\treturn this.read(reader);\n\t}\n\n\ttransform<T2, Input2>({\n\t\tname,\n\t\tinput,\n\t\toutput,\n\t}: {\n\t\tinput: (val: Input2) => Input;\n\t\toutput: (value: T) => T2;\n\t} & BcsTypeOptions<T2, Input2>) {\n\t\treturn new BcsType<T2, Input2>({\n\t\t\tname: name ?? this.name,\n\t\t\tread: (reader) => output(this.read(reader)),\n\t\t\twrite: (value, writer) => this.#write(input(value), writer),\n\t\t\tserializedSize: (value) => this.serializedSize(input(value)),\n\t\t\tserialize: (value, options) => this.#serialize(input(value), options),\n\t\t\tvalidate: (value) => this.validate(input(value)),\n\t\t});\n\t}\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@mysten/serialized-bcs');\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n\t#schema: BcsType<T, Input>;\n\t#bytes: Uint8Array;\n\n\t// Used to brand SerializedBcs so that they can be identified, even between multiple copies\n\t// of the @mysten/bcs package are installed\n\tget [SERIALIZED_BCS_BRAND]() {\n\t\treturn true;\n\t}\n\n\tconstructor(type: BcsType<T, Input>, schema: Uint8Array) {\n\t\tthis.#schema = type;\n\t\tthis.#bytes = schema;\n\t}\n\n\ttoBytes() {\n\t\treturn this.#bytes;\n\t}\n\n\ttoHex() {\n\t\treturn toHEX(this.#bytes);\n\t}\n\n\ttoBase64() {\n\t\treturn toB64(this.#bytes);\n\t}\n\n\ttoBase58() {\n\t\treturn toB58(this.#bytes);\n\t}\n\n\tparse() {\n\t\treturn this.#schema.parse(this.#bytes);\n\t}\n}\n\nexport function fixedSizeBcsType<T, Input = T>({\n\tsize,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\tread: (reader: BcsReader) => T;\n\twrite: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input>) {\n\treturn new BcsType<T, Input>({\n\t\t...options,\n\t\tserializedSize: () => size,\n\t});\n}\n\nexport function uIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${8 | 16 | 32}`;\n\twriteMethod: `write${8 | 16 | 32}`;\n\tmaxValue: number;\n} & BcsTypeOptions<number, number>) {\n\treturn fixedSizeBcsType<number>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](value),\n\t\tvalidate: (value) => {\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function bigUIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${64 | 128 | 256}`;\n\twriteMethod: `write${64 | 128 | 256}`;\n\tmaxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n\treturn fixedSizeBcsType<string, string | number | bigint>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](BigInt(value)),\n\t\tvalidate: (val) => {\n\t\t\tconst value = BigInt(val);\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function dynamicSizeBcsType<T, Input = T>({\n\tserialize,\n\t...options\n}: {\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n} & BcsTypeOptions<T, Input>) {\n\tconst type = new BcsType<T, Input>({\n\t\t...options,\n\t\tserialize,\n\t\twrite: (value, writer) => {\n\t\t\tfor (const byte of type.serialize(value).toBytes()) {\n\t\t\t\twriter.write8(byte);\n\t\t\t}\n\t\t},\n\t});\n\n\treturn type;\n}\n\nexport function stringLikeBcsType({\n\ttoBytes,\n\tfromBytes,\n\t...options\n}: {\n\tname: string;\n\ttoBytes: (value: string) => Uint8Array;\n\tfromBytes: (bytes: Uint8Array) => string;\n\tserializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string>) {\n\treturn new BcsType<string>({\n\t\t...options,\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst bytes = reader.readBytes(length);\n\n\t\t\treturn fromBytes(bytes);\n\t\t},\n\t\twrite: (hex, writer) => {\n\t\t\tconst bytes = toBytes(hex);\n\t\t\twriter.writeULEB(bytes.length);\n\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\twriter.write8(bytes[i]);\n\t\t\t}\n\t\t},\n\t\tserialize: (value) => {\n\t\t\tconst bytes = toBytes(value);\n\t\t\tconst size = ulebEncode(bytes.length);\n\t\t\tconst result = new Uint8Array(size.length + bytes.length);\n\t\t\tresult.set(size, 0);\n\t\t\tresult.set(bytes, size.length);\n\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: (value) => {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n\tlet lazyType: BcsType<T, Input> | null = null;\n\tfunction getType() {\n\t\tif (!lazyType) {\n\t\t\tlazyType = cb();\n\t\t}\n\t\treturn lazyType;\n\t}\n\n\treturn new BcsType<T, Input>({\n\t\tname: 'lazy' as never,\n\t\tread: (data) => getType().read(data),\n\t\tserializedSize: (value) => getType().serializedSize(value),\n\t\twrite: (value, writer) => getType().write(value, writer),\n\t\tserialize: (value, options) => getType().serialize(value, options).toBytes(),\n\t});\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n\tBcsType,\n\tBcsTypeOptions,\n\tbigUIntBcsType,\n\tdynamicSizeBcsType,\n\tfixedSizeBcsType,\n\tlazyBcsType,\n\tstringLikeBcsType,\n\tuIntBcsType,\n} from './bcs-type.js';\nimport { GenericPlaceholder, ReplaceBcsGenerics } from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nexport const bcs = {\n\t/**\n\t * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n\t * @example\n\t * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n\t */\n\tu8(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u8',\n\t\t\treadMethod: 'read8',\n\t\t\twriteMethod: 'write8',\n\t\t\tsize: 1,\n\t\t\tmaxValue: 2 ** 8 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n\t * @example\n\t * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n\t */\n\tu16(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u16',\n\t\t\treadMethod: 'read16',\n\t\t\twriteMethod: 'write16',\n\t\t\tsize: 2,\n\t\t\tmaxValue: 2 ** 16 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n\t * @example\n\t * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n\t */\n\tu32(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u32',\n\t\t\treadMethod: 'read32',\n\t\t\twriteMethod: 'write32',\n\t\t\tsize: 4,\n\t\t\tmaxValue: 2 ** 32 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n\t * @example\n\t * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n\t */\n\tu64(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u64',\n\t\t\treadMethod: 'read64',\n\t\t\twriteMethod: 'write64',\n\t\t\tsize: 8,\n\t\t\tmaxValue: 2n ** 64n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n\t * @example\n\t * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu128(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u128',\n\t\t\treadMethod: 'read128',\n\t\t\twriteMethod: 'write128',\n\t\t\tsize: 16,\n\t\t\tmaxValue: 2n ** 128n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n\t * @example\n\t * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu256(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u256',\n\t\t\treadMethod: 'read256',\n\t\t\twriteMethod: 'write256',\n\t\t\tsize: 32,\n\t\t\tmaxValue: 2n ** 256n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write boolean values.\n\t * @example\n\t * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n\t */\n\tbool(options?: BcsTypeOptions<boolean>) {\n\t\treturn fixedSizeBcsType<boolean>({\n\t\t\tname: 'bool',\n\t\t\tsize: 1,\n\t\t\tread: (reader) => reader.read8() === 1,\n\t\t\twrite: (value, writer) => writer.write8(value ? 1 : 0),\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'boolean') {\n\t\t\t\t\tthrow new TypeError(`Expected boolean, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n\t * @example\n\t *\n\t */\n\tuleb128(options?: BcsTypeOptions<number>) {\n\t\treturn dynamicSizeBcsType<number>({\n\t\t\tname: 'uleb128',\n\t\t\tread: (reader) => reader.readULEB(),\n\t\t\tserialize: (value) => {\n\t\t\t\treturn Uint8Array.from(ulebEncode(value));\n\t\t\t},\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a fixed length byte array\n\t * @param size The number of bytes this types represents\n\t * @example\n\t * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n\t */\n\tbytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn fixedSizeBcsType<Uint8Array>({\n\t\t\tname: `bytes[${size}]`,\n\t\t\tsize,\n\t\t\tread: (reader) => reader.readBytes(size),\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\twriter.write8(value[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n\t * @example\n\t * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n\t */\n\tstring(options?: BcsTypeOptions<string>) {\n\t\treturn stringLikeBcsType({\n\t\t\tname: 'string',\n\t\t\ttoBytes: (value) => new TextEncoder().encode(value),\n\t\t\tfromBytes: (bytes) => new TextDecoder().decode(bytes),\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that represents a fixed length array of a given type\n\t * @param size The number of elements in the array\n\t * @param type The BcsType of each element in the array\n\t * @example\n\t * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n\t */\n\tfixedArray<T, Input>(\n\t\tsize: number,\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `${type.name}[${size}]`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: T[] = new Array(size);\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an optional value\n\t * @param type The BcsType of the optional value\n\t * @example\n\t * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n\t * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n\t */\n\toption<T, Input>(type: BcsType<T, Input>) {\n\t\treturn bcs\n\t\t\t.enum(`Option<${type.name}>`, {\n\t\t\t\tNone: null,\n\t\t\t\tSome: type,\n\t\t\t})\n\t\t\t.transform({\n\t\t\t\tinput: (value: Input | null | undefined) => {\n\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\treturn { None: true };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { Some: value };\n\t\t\t\t},\n\t\t\t\toutput: (value) => {\n\t\t\t\t\tif ('Some' in value) {\n\t\t\t\t\t\treturn value.Some;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length vector of a given type\n\t * @param type The BcsType of each element in the vector\n\t *\n\t * @example\n\t * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n\t */\n\tvector<T, Input>(\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `vector<${type.name}>`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\t\t\t\tconst result: T[] = new Array(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\twriter.writeULEB(value.length);\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a tuple of a given set of types\n\t * @param types The BcsTypes for each element in the tuple\n\t *\n\t * @example\n\t * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n\t * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n\t */\n\ttuple<const Types extends readonly BcsType<any>[]>(\n\t\ttypes: Types,\n\t\toptions?: BcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>,\n\t) {\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>({\n\t\t\tname: `(${types.map((t) => t.name).join(', ')})`,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\tconst size = types[i].serializedSize(values[i]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: unknown[] = [];\n\t\t\t\tfor (const type of types) {\n\t\t\t\t\tresult.push(type.read(reader));\n\t\t\t\t}\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\ttypes[i].write(value[i], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== types.length) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${types.length}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a struct of a given set of fields\n\t * @param name The name of the struct\n\t * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n\t *\n\t * @example\n\t * const struct = bcs.struct('MyStruct', {\n\t *  a: bcs.u8(),\n\t *  b: bcs.string(),\n\t * })\n\t * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t */\n\tstruct<T extends Record<string, BcsType<any>>>(\n\t\tname: string,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t\t}\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(fields);\n\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t}\n\t\t>({\n\t\t\tname,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tconst size = type.serializedSize(values[field]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: Record<string, unknown> = {};\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tresult[field] = type.read(reader);\n\t\t\t\t}\n\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\ttype.write(value[field], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an enum of a given set of options\n\t * @param name The name of the enum\n\t * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n\t * null can be used to represent a variant with no data.\n\t *\n\t * @example\n\t * const enum = bcs.enum('MyEnum', {\n\t *   A: bcs.u8(),\n\t *   B: bcs.string(),\n\t *   C: null,\n\t * })\n\t * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n\t * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n\t */\n\tenum<T extends Record<string, BcsType<any> | null>>(\n\t\tname: string,\n\t\tvalues: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any>\n\t\t\t\t\t\t? { [K2 in K]: U }\n\t\t\t\t\t\t: { [K2 in K]: true };\n\t\t\t\t}[keyof T],\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U>\n\t\t\t\t\t\t? { [K2 in K]: U }\n\t\t\t\t\t\t: { [K2 in K]: unknown };\n\t\t\t\t}[keyof T]\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(values as object);\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? { [K2 in K]: U } : { [K2 in K]: true };\n\t\t\t}[keyof T],\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U>\n\t\t\t\t\t? { [K2 in K]: U }\n\t\t\t\t\t: { [K2 in K]: unknown };\n\t\t\t}[keyof T]\n\t\t>({\n\t\t\tname,\n\t\t\tread: (reader) => {\n\t\t\t\tconst index = reader.readULEB();\n\t\t\t\tconst [name, type] = canonicalOrder[index];\n\t\t\t\treturn {\n\t\t\t\t\t[name]: type?.read(reader) ?? true,\n\t\t\t\t} as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst [name, val] = Object.entries(value)[0];\n\t\t\t\tfor (let i = 0; i < canonicalOrder.length; i++) {\n\t\t\t\t\tconst [optionName, optionType] = canonicalOrder[i];\n\t\t\t\t\tif (optionName === name) {\n\t\t\t\t\t\twriter.writeULEB(i);\n\t\t\t\t\t\toptionType?.write(val, writer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\n\t\t\t\tconst keys = Object.keys(value);\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tthrow new TypeError(`Expected object with one key, found ${keys.length}`);\n\t\t\t\t}\n\n\t\t\t\tconst [name] = keys;\n\n\t\t\t\tif (!Object.hasOwn(values, name)) {\n\t\t\t\t\tthrow new TypeError(`Invalid enum variant ${name}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a map of a given key and value type\n\t * @param keyType The BcsType of the key\n\t * @param valueType The BcsType of the value\n\t * @example\n\t * const map = bcs.map(bcs.u8(), bcs.string())\n\t * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n\t */\n\tmap<K, V, InputK = K, InputV = V>(keyType: BcsType<K, InputK>, valueType: BcsType<V, InputV>) {\n\t\treturn bcs.vector(bcs.tuple([keyType, valueType])).transform({\n\t\t\tname: `Map<${keyType.name}, ${valueType.name}>`,\n\t\t\tinput: (value: Map<InputK, InputV>) => {\n\t\t\t\treturn [...value.entries()];\n\t\t\t},\n\t\t\toutput: (value) => {\n\t\t\t\tconst result = new Map<K, V>();\n\t\t\t\tfor (const [key, val] of value) {\n\t\t\t\t\tresult.set(key, val);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * @deprecated\n\t *\n\t * Generics should be implemented as generic typescript functions instead:\n\t *\n\t * ```ts\n\t * function VecMap<K, V>, (K: BcsType<K>, V: BcsType<V>) {\n\t *   return bcs.struct('VecMap<K, V>', {\n\t *     keys: bcs.vector(K),\n\t *     values: bcs.vector(V),\n\t *   })\n\t * }\n\t * ```\n\t */\n\tgeneric<const Names extends readonly string[], const Type extends BcsType<any>>(\n\t\tnames: Names,\n\t\tcb: (...types: { [K in keyof Names]: BcsType<GenericPlaceholder<Names[K]>> }) => Type,\n\t): <T extends { [K in keyof Names]: BcsType<any> }>(\n\t\t...types: T\n\t) => ReplaceBcsGenerics<Type, Names, T> {\n\t\treturn (...types) => {\n\t\t\treturn cb(...types).transform({\n\t\t\t\tname: `${cb.name}<${types.map((t) => t.name).join(', ')}>`,\n\t\t\t\tinput: (value) => value,\n\t\t\t\toutput: (value) => value,\n\t\t\t}) as never;\n\t\t};\n\t},\n\n\t/**\n\t * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n\t * @param cb A callback that returns the BcsType\n\t */\n\tlazy<T extends BcsType<any>>(cb: () => T): T {\n\t\treturn lazyBcsType(cb) as T;\n\t},\n};\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, toB58 } from './b58.js';\nimport { fromB64, toB64 } from './b64.js';\nimport { BcsType } from './bcs-type.js';\nimport { fromHEX, toHEX } from './hex.js';\nimport { BcsReader } from './reader.js';\nimport { Encoding } from './types.js';\nimport { decodeStr, splitGenericParameters } from './utils.js';\nimport { BcsWriter, BcsWriterOptions } from './writer.js';\n\n/**\n * Allows for array definitions for names.\n * @example\n * ```\n * bcs.registerStructType(['vector', BCS.STRING], ...);\n * // equals\n * bcs.registerStructType('vector<string>', ...);\n * ```\n */\nexport type TypeName = string | [string, ...(TypeName | string)[]];\n\nconst SUI_ADDRESS_LENGTH = 32;\n\nexport interface TypeInterface {\n\tencode: (\n\t\tself: BCS,\n\t\tdata: any,\n\t\toptions: BcsWriterOptions | undefined,\n\t\ttypeParams: TypeName[],\n\t) => BcsWriter;\n\tdecode: (self: BCS, data: Uint8Array, typeParams: TypeName[]) => any;\n\n\t_encodeRaw: (\n\t\twriter: BcsWriter,\n\t\tdata: any,\n\t\ttypeParams: TypeName[],\n\t\ttypeMap: { [key: string]: TypeName },\n\t) => BcsWriter;\n\t_decodeRaw: (\n\t\treader: BcsReader,\n\t\ttypeParams: TypeName[],\n\t\ttypeMap: { [key: string]: TypeName },\n\t) => any;\n}\n\n/**\n * Struct type definition. Used as input format in BcsConfig.types\n * as well as an argument type for `bcs.registerStructType`.\n */\nexport type StructTypeDefinition = {\n\t[key: string]: TypeName | StructTypeDefinition;\n};\n\n/**\n * Enum type definition. Used as input format in BcsConfig.types\n * as well as an argument type for `bcs.registerEnumType`.\n *\n * Value can be either `string` when invariant has a type or `null`\n * when invariant is empty.\n *\n * @example\n * bcs.registerEnumType('Option<T>', {\n *   some: 'T',\n *   none: null\n * });\n */\nexport type EnumTypeDefinition = {\n\t[key: string]: TypeName | StructTypeDefinition | null;\n};\n\n/**\n * Configuration that is passed into BCS constructor.\n */\nexport type BcsConfig = {\n\t/**\n\t * Defines type name for the vector / array type.\n\t * In Move: `vector<T>` or `vector`.\n\t */\n\tvectorType: string;\n\t/**\n\t * Address length. Varies depending on a platform and\n\t * has to be specified for the `address` type.\n\t */\n\taddressLength: number;\n\n\t/**\n\t * Custom encoding for address. Supported values are\n\t * either 'hex' or 'base64'.\n\t */\n\taddressEncoding?: 'hex' | 'base64';\n\t/**\n\t * Opening and closing symbol for type parameters. Can be\n\t * any pair of symbols (eg `['(', ')']`); default value follows\n\t * Rust and Move: `<` and `>`.\n\t */\n\tgenericSeparators?: [string, string];\n\t/**\n\t * Type definitions for the BCS. This field allows spawning\n\t * BCS instance from JSON or another prepared configuration.\n\t * Optional.\n\t */\n\ttypes?: {\n\t\tstructs?: { [key: string]: StructTypeDefinition };\n\t\tenums?: { [key: string]: EnumTypeDefinition };\n\t\taliases?: { [key: string]: string };\n\t};\n\t/**\n\t * Whether to auto-register primitive types on launch.\n\t */\n\twithPrimitives?: boolean;\n};\n\n/**\n * BCS implementation for Move types and few additional built-ins.\n */\nexport class BCS {\n\t// Predefined types constants\n\tstatic readonly U8 = 'u8';\n\tstatic readonly U16 = 'u16';\n\tstatic readonly U32 = 'u32';\n\tstatic readonly U64 = 'u64';\n\tstatic readonly U128 = 'u128';\n\tstatic readonly U256 = 'u256';\n\tstatic readonly BOOL = 'bool';\n\tstatic readonly VECTOR = 'vector';\n\tstatic readonly ADDRESS = 'address';\n\tstatic readonly STRING = 'string';\n\tstatic readonly HEX = 'hex-string';\n\tstatic readonly BASE58 = 'base58-string';\n\tstatic readonly BASE64 = 'base64-string';\n\n\t/**\n\t * Map of kind `TypeName => TypeInterface`. Holds all\n\t * callbacks for (de)serialization of every registered type.\n\t *\n\t * If the value stored is a string, it is treated as an alias.\n\t */\n\tpublic types: Map<string, TypeInterface | string> = new Map();\n\n\t/**\n\t * Stored BcsConfig for the current instance of BCS.\n\t */\n\tprotected schema: BcsConfig;\n\n\t/**\n\t * Count temp keys to generate a new one when requested.\n\t */\n\tprotected counter: number = 0;\n\n\t/**\n\t * Name of the key to use for temporary struct definitions.\n\t * Returns a temp key + index (for a case when multiple temp\n\t * structs are processed).\n\t */\n\tprivate tempKey() {\n\t\treturn `bcs-struct-${++this.counter}`;\n\t}\n\n\t/**\n\t * Construct a BCS instance with a prepared schema.\n\t *\n\t * @param schema A prepared schema with type definitions\n\t * @param withPrimitives Whether to register primitive types by default\n\t */\n\tconstructor(schema: BcsConfig | BCS) {\n\t\t// if BCS instance is passed -> clone its schema\n\t\tif (schema instanceof BCS) {\n\t\t\tthis.schema = schema.schema;\n\t\t\tthis.types = new Map(schema.types);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.schema = schema;\n\n\t\t// Register address type under key 'address'.\n\t\tthis.registerAddressType(BCS.ADDRESS, schema.addressLength, schema.addressEncoding);\n\t\tthis.registerVectorType(schema.vectorType);\n\n\t\t// Register struct types if they were passed.\n\t\tif (schema.types && schema.types.structs) {\n\t\t\tfor (let name of Object.keys(schema.types.structs)) {\n\t\t\t\tthis.registerStructType(name, schema.types.structs[name]);\n\t\t\t}\n\t\t}\n\n\t\t// Register enum types if they were passed.\n\t\tif (schema.types && schema.types.enums) {\n\t\t\tfor (let name of Object.keys(schema.types.enums)) {\n\t\t\t\tthis.registerEnumType(name, schema.types.enums[name]);\n\t\t\t}\n\t\t}\n\n\t\t// Register aliases if they were passed.\n\t\tif (schema.types && schema.types.aliases) {\n\t\t\tfor (let name of Object.keys(schema.types.aliases)) {\n\t\t\t\tthis.registerAlias(name, schema.types.aliases[name]);\n\t\t\t}\n\t\t}\n\n\t\tif (schema.withPrimitives !== false) {\n\t\t\tregisterPrimitives(this);\n\t\t}\n\t}\n\n\t/**\n\t * Serialize data into bcs.\n\t *\n\t * @example\n\t * bcs.registerVectorType('vector<u8>', 'u8');\n\t *\n\t * let serialized = BCS\n\t *   .set('vector<u8>', [1,2,3,4,5,6])\n\t *   .toBytes();\n\t *\n\t * console.assert(toHex(serialized) === '06010203040506');\n\t *\n\t * @param type Name of the type to serialize (must be registered) or a struct type.\n\t * @param data Data to serialize.\n\t * @param size Serialization buffer size. Default 1024 = 1KB.\n\t * @return A BCS reader instance. Usually you'd want to call `.toBytes()`\n\t */\n\tpublic ser(\n\t\ttype: TypeName | StructTypeDefinition,\n\t\tdata: any,\n\t\toptions?: BcsWriterOptions,\n\t): BcsWriter {\n\t\tif (typeof type === 'string' || Array.isArray(type)) {\n\t\t\tconst { name, params } = this.parseTypeName(type);\n\t\t\treturn this.getTypeInterface(name).encode(this, data, options, params as string[]);\n\t\t}\n\n\t\t// Quick serialization without registering the type in the main struct.\n\t\tif (typeof type === 'object') {\n\t\t\tconst key = this.tempKey();\n\t\t\tconst temp = new BCS(this);\n\t\t\treturn temp.registerStructType(key, type).ser(key, data, options);\n\t\t}\n\n\t\tthrow new Error(`Incorrect type passed into the '.ser()' function. \\n${JSON.stringify(type)}`);\n\t}\n\n\t/**\n\t * Deserialize BCS into a JS type.\n\t *\n\t * @example\n\t * let num = bcs.ser('u64', '4294967295').toString('hex');\n\t * let deNum = bcs.de('u64', num, 'hex');\n\t * console.assert(deNum.toString(10) === '4294967295');\n\t *\n\t * @param type Name of the type to deserialize (must be registered) or a struct type definition.\n\t * @param data Data to deserialize.\n\t * @param encoding Optional - encoding to use if data is of type String\n\t * @return Deserialized data.\n\t */\n\tpublic de(\n\t\ttype: TypeName | StructTypeDefinition,\n\t\tdata: Uint8Array | string,\n\t\tencoding?: Encoding,\n\t): any {\n\t\tif (typeof data === 'string') {\n\t\t\tif (encoding) {\n\t\t\t\tdata = decodeStr(data, encoding);\n\t\t\t} else {\n\t\t\t\tthrow new Error('To pass a string to `bcs.de`, specify encoding');\n\t\t\t}\n\t\t}\n\n\t\t// In case the type specified is already registered.\n\t\tif (typeof type === 'string' || Array.isArray(type)) {\n\t\t\tconst { name, params } = this.parseTypeName(type);\n\t\t\treturn this.getTypeInterface(name).decode(this, data, params as string[]);\n\t\t}\n\n\t\t// Deserialize without registering a type using a temporary clone.\n\t\tif (typeof type === 'object') {\n\t\t\tconst temp = new BCS(this);\n\t\t\tconst key = this.tempKey();\n\t\t\treturn temp.registerStructType(key, type).de(key, data, encoding);\n\t\t}\n\n\t\tthrow new Error(`Incorrect type passed into the '.de()' function. \\n${JSON.stringify(type)}`);\n\t}\n\n\t/**\n\t * Check whether a `TypeInterface` has been loaded for a `type`.\n\t * @param type Name of the type to check.\n\t * @returns\n\t */\n\tpublic hasType(type: string): boolean {\n\t\treturn this.types.has(type);\n\t}\n\n\t/**\n\t * Create an alias for a type.\n\t * WARNING: this can potentially lead to recursion\n\t * @param name Alias to use\n\t * @param forType Type to reference\n\t * @returns\n\t *\n\t * @example\n\t * ```\n\t * let bcs = new BCS(getSuiMoveConfig());\n\t * bcs.registerAlias('ObjectDigest', BCS.BASE58);\n\t * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');\n\t * ```\n\t */\n\tpublic registerAlias(name: string, forType: string): BCS {\n\t\tthis.types.set(name, forType);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Method to register new types for BCS internal representation.\n\t * For each registered type 2 callbacks must be specified and one is optional:\n\t *\n\t * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;\n\t * - decodeCb(reader) - write a way to deserialize data with BcsReader;\n\t * - validateCb(data) - validate data - either return bool or throw an error\n\t *\n\t * @example\n\t * // our type would be a string that consists only of numbers\n\t * bcs.registerType('number_string',\n\t *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),\n\t *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8\n\t *    (value) => /[0-9]+/.test(value) // test that it has at least one digit\n\t * );\n\t * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);\n\t *\n\t * @param name\n\t * @param encodeCb Callback to encode a value.\n\t * @param decodeCb Callback to decode a value.\n\t * @param validateCb Optional validator Callback to check type before serialization.\n\t */\n\tpublic registerType(\n\t\ttypeName: TypeName,\n\t\tencodeCb: (\n\t\t\twriter: BcsWriter,\n\t\t\tdata: any,\n\t\t\ttypeParams: TypeName[],\n\t\t\ttypeMap: { [key: string]: TypeName },\n\t\t) => BcsWriter,\n\t\tdecodeCb: (\n\t\t\treader: BcsReader,\n\t\t\ttypeParams: TypeName[],\n\t\t\ttypeMap: { [key: string]: TypeName },\n\t\t) => any,\n\t\tvalidateCb: (data: any) => boolean = () => true,\n\t): BCS {\n\t\tconst { name, params: generics } = this.parseTypeName(typeName);\n\n\t\tthis.types.set(name, {\n\t\t\tencode(self: BCS, data, options: BcsWriterOptions, typeParams) {\n\t\t\t\tconst typeMap = (generics as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t}, {});\n\n\t\t\t\treturn this._encodeRaw.call(self, new BcsWriter(options), data, typeParams, typeMap);\n\t\t\t},\n\t\t\tdecode(self: BCS, data, typeParams) {\n\t\t\t\tconst typeMap = (generics as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t}, {});\n\n\t\t\t\treturn this._decodeRaw.call(self, new BcsReader(data), typeParams, typeMap);\n\t\t\t},\n\n\t\t\t// these methods should always be used with caution as they require pre-defined\n\t\t\t// reader and writer and mainly exist to allow multi-field (de)serialization;\n\t\t\t_encodeRaw(writer, data, typeParams, typeMap) {\n\t\t\t\tif (validateCb(data)) {\n\t\t\t\t\treturn encodeCb.call(this, writer, data, typeParams, typeMap);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(`Validation failed for type ${name}, data: ${data}`);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_decodeRaw(reader, typeParams, typeMap) {\n\t\t\t\treturn decodeCb.call(this, reader, typeParams, typeMap);\n\t\t\t},\n\t\t} as TypeInterface);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Method to register BcsType instances to the registry\n\t * Types are registered with a callback that provides BcsType instances for each generic\n\t * passed to the type.\n\t *\n\t * - createType(...generics) - Return a BcsType instance\n\t *\n\t * @example\n\t * // our type would be a string that consists only of numbers\n\t * bcs.registerType('Box<T>', (T) => {\n\t * \t\treturn bcs.struct({\n\t * \t\t\tvalue: T\n\t * \t\t});\n\t * });\n\n\t * console.log(Array.from(bcs.ser('Box<string>', '12345').toBytes()) == [5,1,2,3,4,5]);\n\t *\n\t * @param name\n\t * @param createType a Callback to create the BcsType with any passed in generics\n\t */\n\tpublic registerBcsType(\n\t\ttypeName: TypeName,\n\t\tcreateType: (...params: BcsType<any>[]) => BcsType<any>,\n\t) {\n\t\tthis.registerType(\n\t\t\ttypeName,\n\t\t\t(writer, data, typeParams) => {\n\t\t\t\tconst generics = typeParams.map(\n\t\t\t\t\t(param) =>\n\t\t\t\t\t\tnew BcsType<unknown>({\n\t\t\t\t\t\t\tname: String(param),\n\t\t\t\t\t\t\twrite: (data, writer) => {\n\t\t\t\t\t\t\t\tconst { name, params } = this.parseTypeName(param);\n\t\t\t\t\t\t\t\tconst typeInterface = this.getTypeInterface(name);\n\n\t\t\t\t\t\t\t\tconst typeMap = (params as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t\t\t\t\t}, {});\n\n\t\t\t\t\t\t\t\treturn typeInterface._encodeRaw.call(this, writer, data, params, typeMap);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tread: () => {\n\t\t\t\t\t\t\t\tthrow new Error('Not implemented');\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t);\n\n\t\t\t\tcreateType(...generics).write(data, writer);\n\t\t\t\treturn writer;\n\t\t\t},\n\t\t\t(reader, typeParams) => {\n\t\t\t\tconst generics = typeParams.map(\n\t\t\t\t\t(param) =>\n\t\t\t\t\t\tnew BcsType<unknown>({\n\t\t\t\t\t\t\tname: String(param),\n\t\t\t\t\t\t\twrite: (data, writer) => {\n\t\t\t\t\t\t\t\tthrow new Error('Not implemented');\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tread: (reader) => {\n\t\t\t\t\t\t\t\tconst { name, params } = this.parseTypeName(param);\n\t\t\t\t\t\t\t\tconst typeInterface = this.getTypeInterface(name);\n\n\t\t\t\t\t\t\t\tconst typeMap = (params as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t\t\t\t\t}, {});\n\n\t\t\t\t\t\t\t\treturn typeInterface._decodeRaw.call(this, reader, params, typeMap);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t);\n\n\t\t\t\treturn createType(...generics).read(reader);\n\t\t\t},\n\t\t);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Register an address type which is a sequence of U8s of specified length.\n\t * @example\n\t * bcs.registerAddressType('address', SUI_ADDRESS_LENGTH);\n\t * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');\n\t *\n\t * @param name Name of the address type.\n\t * @param length Byte length of the address.\n\t * @param encoding Encoding to use for the address type\n\t * @returns\n\t */\n\tpublic registerAddressType(name: string, length: number, encoding: Encoding | void = 'hex'): BCS {\n\t\tswitch (encoding) {\n\t\t\tcase 'base64':\n\t\t\t\treturn this.registerType(\n\t\t\t\t\tname,\n\t\t\t\t\tfunction encodeAddress(writer, data: string) {\n\t\t\t\t\t\treturn fromB64(data).reduce((writer, el) => writer.write8(el), writer);\n\t\t\t\t\t},\n\t\t\t\t\tfunction decodeAddress(reader) {\n\t\t\t\t\t\treturn toB64(reader.readBytes(length));\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\tcase 'hex':\n\t\t\t\treturn this.registerType(\n\t\t\t\t\tname,\n\t\t\t\t\tfunction encodeAddress(writer, data: string) {\n\t\t\t\t\t\treturn fromHEX(data).reduce((writer, el) => writer.write8(el), writer);\n\t\t\t\t\t},\n\t\t\t\t\tfunction decodeAddress(reader) {\n\t\t\t\t\t\treturn toHEX(reader.readBytes(length));\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unsupported encoding! Use either hex or base64');\n\t\t}\n\t}\n\n\t/**\n\t * Register custom vector type inside the bcs.\n\t *\n\t * @example\n\t * bcs.registerVectorType('vector<T>'); // generic registration\n\t * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];\n\t * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');\n\t *\n\t * @param name Name of the type to register\n\t * @param elementType Optional name of the inner type of the vector\n\t * @return Returns self for chaining.\n\t */\n\tprivate registerVectorType(typeName: string): BCS {\n\t\tlet { name, params } = this.parseTypeName(typeName);\n\t\tif (params.length > 1) {\n\t\t\tthrow new Error('Vector can have only one type parameter; got ' + name);\n\t\t}\n\n\t\treturn this.registerType(\n\t\t\ttypeName,\n\t\t\tfunction encodeVector(\n\t\t\t\tthis: BCS,\n\t\t\t\twriter: BcsWriter,\n\t\t\t\tdata: any[],\n\t\t\t\ttypeParams: TypeName[],\n\t\t\t\ttypeMap,\n\t\t\t) {\n\t\t\t\treturn writer.writeVec(data, (writer, el) => {\n\t\t\t\t\tlet elementType: TypeName = typeParams[0];\n\t\t\t\t\tif (!elementType) {\n\t\t\t\t\t\tthrow new Error(`Incorrect number of type parameters passed a to vector '${typeName}'`);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name, params } = this.parseTypeName(elementType);\n\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\treturn this.getTypeInterface(name)._encodeRaw.call(this, writer, el, params, typeMap);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in vector; make sure you passed a generic`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\n\t\t\t\t\treturn this.getTypeInterface(innerName)._encodeRaw.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\twriter,\n\t\t\t\t\t\tel,\n\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\t\t\tfunction decodeVector(this: BCS, reader: BcsReader, typeParams, typeMap) {\n\t\t\t\treturn reader.readVec((reader) => {\n\t\t\t\t\tlet elementType: TypeName = typeParams[0];\n\t\t\t\t\tif (!elementType) {\n\t\t\t\t\t\tthrow new Error(`Incorrect number of type parameters passed to a vector '${typeName}'`);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name, params } = this.parseTypeName(elementType);\n\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\treturn this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in vector; make sure you passed a generic`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\n\t\t\t\t\treturn this.getTypeInterface(innerName)._decodeRaw.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\treader,\n\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\t\t);\n\t}\n\n\t/**\n\t * Safe method to register a custom Move struct. The first argument is a name of the\n\t * struct which is only used on the FrontEnd and has no affect on serialization results,\n\t * and the second is a struct description passed as an Object.\n\t *\n\t * The description object MUST have the same order on all of the platforms (ie in Move\n\t * or in Rust).\n\t *\n\t * @example\n\t * // Move / Rust struct\n\t * // struct Coin {\n\t * //   value: u64,\n\t * //   owner: vector<u8>, // name // Vec<u8> in Rust\n\t * //   is_locked: bool,\n\t * // }\n\t *\n\t * bcs.registerStructType('Coin', {\n\t *   value: bcs.U64,\n\t *   owner: bcs.STRING,\n\t *   is_locked: bcs.BOOL\n\t * });\n\t *\n\t * // Created in Rust with diem/bcs\n\t * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';\n\t * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array\n\t *  128, 209, 177,   5,  96,  0,  0,\n\t *    0,  14,  66, 105, 103, 32, 87,\n\t *   97, 108, 108, 101, 116, 32, 71,\n\t *  117, 121,   0\n\t * ];\n\t *\n\t * // Let's encode the value as well\n\t * let test_set = bcs.ser('Coin', {\n\t *   owner: 'Big Wallet Guy',\n\t *   value: '412412400000',\n\t *   is_locked: false,\n\t * });\n\t *\n\t * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');\n\t *\n\t * @param name Name of the type to register.\n\t * @param fields Fields of the struct. Must be in the correct order.\n\t * @return Returns BCS for chaining.\n\t */\n\tpublic registerStructType(typeName: TypeName, fields: StructTypeDefinition): BCS {\n\t\t// When an Object is passed, we register it under a new key and store it\n\t\t// in the registered type system. This way we allow nested inline definitions.\n\t\tfor (let key in fields) {\n\t\t\tlet internalName = this.tempKey();\n\t\t\tlet value = fields[key];\n\n\t\t\t// TODO: add a type guard here?\n\t\t\tif (!Array.isArray(value) && typeof value !== 'string') {\n\t\t\t\tfields[key] = internalName;\n\t\t\t\tthis.registerStructType(internalName, value as StructTypeDefinition);\n\t\t\t}\n\t\t}\n\n\t\tlet struct = Object.freeze(fields); // Make sure the order doesn't get changed\n\n\t\t// IMPORTANT: we need to store canonical order of fields for each registered\n\t\t// struct so we maintain it and allow developers to use any field ordering in\n\t\t// their code (and not cause mismatches based on field order).\n\t\tlet canonicalOrder = Object.keys(struct);\n\n\t\t// Holds generics for the struct definition. At this stage we can check that\n\t\t// generic parameter matches the one defined in the struct.\n\t\tlet { name: structName, params: generics } = this.parseTypeName(typeName);\n\n\t\t// Make sure all the types in the fields description are already known\n\t\t// and that all the field types are strings.\n\t\treturn this.registerType(\n\t\t\ttypeName,\n\t\t\tfunction encodeStruct(\n\t\t\t\tthis: BCS,\n\t\t\t\twriter: BcsWriter,\n\t\t\t\tdata: { [key: string]: any },\n\t\t\t\ttypeParams,\n\t\t\t\ttypeMap,\n\t\t\t) {\n\t\t\t\tif (!data || data.constructor !== Object) {\n\t\t\t\t\tthrow new Error(`Expected ${structName} to be an Object, got: ${data}`);\n\t\t\t\t}\n\n\t\t\t\tif (typeParams.length !== generics.length) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// follow the canonical order when serializing\n\t\t\t\tfor (let key of canonicalOrder) {\n\t\t\t\t\tif (!(key in data)) {\n\t\t\t\t\t\tthrow new Error(`Struct ${structName} requires field ${key}:${struct[key]}`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Before deserializing, read the canonical field type.\n\t\t\t\t\tconst { name: fieldType, params: fieldParams } = this.parseTypeName(\n\t\t\t\t\t\tstruct[key] as TypeName,\n\t\t\t\t\t);\n\n\t\t\t\t\t// Check whether this type is a generic defined in this struct.\n\t\t\t\t\t// If it is -> read the type parameter matching its index.\n\t\t\t\t\t// If not - tread as a regular field.\n\t\t\t\t\tif (!generics.includes(fieldType)) {\n\t\t\t\t\t\tthis.getTypeInterface(fieldType)._encodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\twriter,\n\t\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\t\tfieldParams,\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst paramIdx = generics.indexOf(fieldType);\n\t\t\t\t\t\tlet { name, params } = this.parseTypeName(typeParams[paramIdx]);\n\n\t\t\t\t\t\t// If the type from the type parameters already exists\n\t\t\t\t\t\t// and known -> proceed with type decoding.\n\t\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\t\tthis.getTypeInterface(name)._encodeRaw.call(\n\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\twriter,\n\t\t\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\t\t\tparams as string[],\n\t\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Alternatively, if it's a global generic parameter...\n\t\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\t\t\t\t\t\tthis.getTypeInterface(innerName)._encodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\twriter,\n\t\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn writer;\n\t\t\t},\n\t\t\tfunction decodeStruct(this: BCS, reader: BcsReader, typeParams, typeMap) {\n\t\t\t\tif (typeParams.length !== generics.length) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet result: { [key: string]: any } = {};\n\t\t\t\tfor (let key of canonicalOrder) {\n\t\t\t\t\tconst { name: fieldName, params: fieldParams } = this.parseTypeName(\n\t\t\t\t\t\tstruct[key] as TypeName,\n\t\t\t\t\t);\n\n\t\t\t\t\t// if it's not a generic\n\t\t\t\t\tif (!generics.includes(fieldName)) {\n\t\t\t\t\t\tresult[key] = this.getTypeInterface(fieldName)._decodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\treader,\n\t\t\t\t\t\t\tfieldParams as string[],\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst paramIdx = generics.indexOf(fieldName);\n\t\t\t\t\t\tlet { name, params } = this.parseTypeName(typeParams[paramIdx]);\n\n\t\t\t\t\t\t// If the type from the type parameters already exists\n\t\t\t\t\t\t// and known -> proceed with type decoding.\n\t\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\t\tresult[key] = this.getTypeInterface(name)._decodeRaw.call(\n\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\treader,\n\t\t\t\t\t\t\t\tparams,\n\t\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\t\t\t\t\t\tresult[key] = this.getTypeInterface(innerName)._decodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\treader,\n\t\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t);\n\t}\n\n\t/**\n\t * Safe method to register custom enum type where each invariant holds the value of another type.\n\t * @example\n\t * bcs.registerStructType('Coin', { value: 'u64' });\n\t * bcs.registerEnumType('MyEnum', {\n\t *  single: 'Coin',\n\t *  multi: 'vector<Coin>',\n\t *  empty: null\n\t * });\n\t *\n\t * console.log(\n\t *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }\n\t *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }\n\t * )\n\t *\n\t * // and serialization\n\t * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();\n\t * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });\n\t *\n\t * @param name\n\t * @param variants\n\t */\n\tpublic registerEnumType(typeName: TypeName, variants: EnumTypeDefinition): BCS {\n\t\t// When an Object is passed, we register it under a new key and store it\n\t\t// in the registered type system. This way we allow nested inline definitions.\n\t\tfor (let key in variants) {\n\t\t\tlet internalName = this.tempKey();\n\t\t\tlet value = variants[key];\n\n\t\t\tif (value !== null && !Array.isArray(value) && typeof value !== 'string') {\n\t\t\t\tvariants[key] = internalName;\n\t\t\t\tthis.registerStructType(internalName, value as StructTypeDefinition);\n\t\t\t}\n\t\t}\n\n\t\tlet struct = Object.freeze(variants); // Make sure the order doesn't get changed\n\n\t\t// IMPORTANT: enum is an ordered type and we have to preserve ordering in BCS\n\t\tlet canonicalOrder = Object.keys(struct);\n\n\t\t// Parse type parameters in advance to know the index of each generic parameter.\n\t\tlet { name, params: canonicalTypeParams } = this.parseTypeName(typeName);\n\n\t\treturn this.registerType(\n\t\t\ttypeName,\n\t\t\tfunction encodeEnum(\n\t\t\t\tthis: BCS,\n\t\t\t\twriter: BcsWriter,\n\t\t\t\tdata: { [key: string]: any | null },\n\t\t\t\ttypeParams,\n\t\t\t\ttypeMap,\n\t\t\t) {\n\t\t\t\tif (!data) {\n\t\t\t\t\tthrow new Error(`Unable to write enum \"${name}\", missing data.\\nReceived: \"${data}\"`);\n\t\t\t\t}\n\t\t\t\tif (typeof data !== 'object') {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Incorrect data passed into enum \"${name}\", expected object with properties: \"${canonicalOrder.join(\n\t\t\t\t\t\t\t' | ',\n\t\t\t\t\t\t)}\".\\nReceived: \"${JSON.stringify(data)}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet key = Object.keys(data)[0];\n\t\t\t\tif (key === undefined) {\n\t\t\t\t\tthrow new Error(`Empty object passed as invariant of the enum \"${name}\"`);\n\t\t\t\t}\n\n\t\t\t\tlet orderByte = canonicalOrder.indexOf(key);\n\t\t\t\tif (orderByte === -1) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Unknown invariant of the enum \"${name}\", allowed values: \"${canonicalOrder.join(\n\t\t\t\t\t\t\t' | ',\n\t\t\t\t\t\t)}\"; received \"${key}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tlet invariant = canonicalOrder[orderByte];\n\t\t\t\tlet invariantType = struct[invariant] as TypeName | null;\n\n\t\t\t\t// write order byte\n\t\t\t\twriter.write8(orderByte);\n\n\t\t\t\t// When { \"key\": null } - empty value for the invariant.\n\t\t\t\tif (invariantType === null) {\n\t\t\t\t\treturn writer;\n\t\t\t\t}\n\n\t\t\t\tlet paramIndex = canonicalTypeParams.indexOf(invariantType);\n\t\t\t\tlet typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n\n\t\t\t\t{\n\t\t\t\t\tlet { name, params } = this.parseTypeName(typeOrParam);\n\t\t\t\t\treturn this.getTypeInterface(name)._encodeRaw.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\twriter,\n\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\tparams,\n\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunction decodeEnum(this: BCS, reader: BcsReader, typeParams, typeMap) {\n\t\t\t\tlet orderByte = reader.readULEB();\n\t\t\t\tlet invariant = canonicalOrder[orderByte];\n\t\t\t\tlet invariantType = struct[invariant] as TypeName | null;\n\n\t\t\t\tif (orderByte === -1) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Decoding type mismatch, expected enum \"${name}\" invariant index, received \"${orderByte}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Encode an empty value for the enum.\n\t\t\t\tif (invariantType === null) {\n\t\t\t\t\treturn { [invariant]: true };\n\t\t\t\t}\n\n\t\t\t\tlet paramIndex = canonicalTypeParams.indexOf(invariantType);\n\t\t\t\tlet typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n\n\t\t\t\t{\n\t\t\t\t\tlet { name, params } = this.parseTypeName(typeOrParam);\n\t\t\t\t\treturn {\n\t\t\t\t\t\t[invariant]: this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t}\n\t/**\n\t * Get a set of encoders/decoders for specific type.\n\t * Mainly used to define custom type de/serialization logic.\n\t *\n\t * @param type\n\t * @returns {TypeInterface}\n\t */\n\tpublic getTypeInterface(type: string): TypeInterface {\n\t\tlet typeInterface = this.types.get(type);\n\n\t\t// Special case - string means an alias.\n\t\t// Goes through the alias chain and tracks recursion.\n\t\tif (typeof typeInterface === 'string') {\n\t\t\tlet chain: string[] = [];\n\t\t\twhile (typeof typeInterface === 'string') {\n\t\t\t\tif (chain.includes(typeInterface)) {\n\t\t\t\t\tthrow new Error(`Recursive definition found: ${chain.join(' -> ')} -> ${typeInterface}`);\n\t\t\t\t}\n\t\t\t\tchain.push(typeInterface);\n\t\t\t\ttypeInterface = this.types.get(typeInterface);\n\t\t\t}\n\t\t}\n\n\t\tif (typeInterface === undefined) {\n\t\t\tthrow new Error(`Type ${type} is not registered`);\n\t\t}\n\n\t\treturn typeInterface;\n\t}\n\n\t/**\n\t * Parse a type name and get the type's generics.\n\t * @example\n\t * let { typeName, typeParams } = parseTypeName('Option<Coin<SUI>>');\n\t * // typeName: Option\n\t * // typeParams: [ 'Coin<SUI>' ]\n\t *\n\t * @param name Name of the type to process\n\t * @returns Object with typeName and typeParams listed as Array\n\t */\n\tpublic parseTypeName(name: TypeName): {\n\t\tname: string;\n\t\tparams: TypeName[];\n\t} {\n\t\tif (Array.isArray(name)) {\n\t\t\tlet [typeName, ...params] = name;\n\t\t\treturn { name: typeName, params };\n\t\t}\n\n\t\tif (typeof name !== 'string') {\n\t\t\tthrow new Error(`Illegal type passed as a name of the type: ${name}`);\n\t\t}\n\n\t\tlet [left, right] = this.schema.genericSeparators || ['<', '>'];\n\n\t\tlet l_bound = name.indexOf(left);\n\t\tlet r_bound = Array.from(name).reverse().indexOf(right);\n\n\t\t// if there are no generics - exit gracefully.\n\t\tif (l_bound === -1 && r_bound === -1) {\n\t\t\treturn { name: name, params: [] };\n\t\t}\n\n\t\t// if one of the bounds is not defined - throw an Error.\n\t\tif (l_bound === -1 || r_bound === -1) {\n\t\t\tthrow new Error(`Unclosed generic in name '${name}'`);\n\t\t}\n\n\t\tlet typeName = name.slice(0, l_bound);\n\t\tlet params = splitGenericParameters(\n\t\t\tname.slice(l_bound + 1, name.length - r_bound - 1),\n\t\t\tthis.schema.genericSeparators,\n\t\t);\n\n\t\treturn { name: typeName, params };\n\t}\n}\n\n/**\n * Register the base set of primitive and common types.\n * Is called in the `BCS` constructor automatically but can\n * be ignored if the `withPrimitives` argument is not set.\n */\nexport function registerPrimitives(bcs: BCS): void {\n\tbcs.registerType(\n\t\tBCS.U8,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write8(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read8();\n\t\t},\n\t\t(u8) => u8 < 256,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U16,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write16(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read16();\n\t\t},\n\t\t(u16) => u16 < 65536,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U32,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write32(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read32();\n\t\t},\n\t\t(u32) => u32 <= 4294967296n,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U64,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write64(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read64();\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U128,\n\t\tfunction (writer: BcsWriter, data: bigint) {\n\t\t\treturn writer.write128(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read128();\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U256,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write256(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read256();\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.BOOL,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write8(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read8().toString(10) === '1';\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.STRING,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(data), (writer, el) => writer.write8(el.charCodeAt(0)));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader\n\t\t\t\t.readVec((reader) => reader.read8())\n\t\t\t\t.map((el: bigint) => String.fromCharCode(Number(el)))\n\t\t\t\t.join('');\n\t\t},\n\t\t(_str: string) => true,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.HEX,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(fromHEX(data)), (writer, el) => writer.write8(el));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\tlet bytes = reader.readVec((reader) => reader.read8());\n\t\t\treturn toHEX(new Uint8Array(bytes));\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.BASE58,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(fromB58(data)), (writer, el) => writer.write8(el));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\tlet bytes = reader.readVec((reader) => reader.read8());\n\t\t\treturn toB58(new Uint8Array(bytes));\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.BASE64,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(fromB64(data)), (writer, el) => writer.write8(el));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\tlet bytes = reader.readVec((reader) => reader.read8());\n\t\t\treturn toB64(new Uint8Array(bytes));\n\t\t},\n\t);\n}\n\nexport function getRustConfig(): BcsConfig {\n\treturn {\n\t\tgenericSeparators: ['<', '>'],\n\t\tvectorType: 'Vec',\n\t\taddressLength: SUI_ADDRESS_LENGTH,\n\t\taddressEncoding: 'hex',\n\t};\n}\n\nexport function getSuiMoveConfig(): BcsConfig {\n\treturn {\n\t\tgenericSeparators: ['<', '>'],\n\t\tvectorType: 'vector',\n\t\taddressLength: SUI_ADDRESS_LENGTH,\n\t\taddressEncoding: 'hex',\n\t};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}