{"ast":null,"code":"// src/index.ts\nimport { getWallets, isWalletWithSuiFeatures } from \"@mysten/wallet-standard\";\n\n// src/storage.ts\nvar localStorageAdapter = {\n  async set(key, value) {\n    return localStorage.setItem(key, value);\n  },\n  async get(key) {\n    return localStorage.getItem(key);\n  },\n  async del(key) {\n    localStorage.removeItem(key);\n  }\n};\nvar noopStorageAdapter = {\n  async set() {},\n  async get() {\n    return null;\n  },\n  async del() {}\n};\n\n// src/index.ts\nvar DEFAULT_FEATURES = [\"sui:signAndExecuteTransactionBlock\"];\nvar WalletKitCoreConnectionStatus = /* @__PURE__ */(WalletKitCoreConnectionStatus2 => {\n  WalletKitCoreConnectionStatus2[\"DISCONNECTED\"] = \"DISCONNECTED\";\n  WalletKitCoreConnectionStatus2[\"CONNECTING\"] = \"CONNECTING\";\n  WalletKitCoreConnectionStatus2[\"CONNECTED\"] = \"CONNECTED\";\n  WalletKitCoreConnectionStatus2[\"ERROR\"] = \"ERROR\";\n  return WalletKitCoreConnectionStatus2;\n})(WalletKitCoreConnectionStatus || {});\nvar SUI_WALLET_NAME = \"Sui Wallet\";\nvar RECENT_WALLET_STORAGE = \"wallet-kit:last-wallet\";\nfunction waitToBeVisible() {\n  if (!document || document.visibilityState === \"visible\") {\n    return Promise.resolve();\n  }\n  let promiseResolve = null;\n  const promise = new Promise(r => promiseResolve = r);\n  const callback = () => {\n    if (promiseResolve && document.visibilityState === \"visible\") {\n      promiseResolve();\n      document.removeEventListener(\"visibilitychange\", callback);\n    }\n  };\n  document.addEventListener(\"visibilitychange\", callback);\n  return promise;\n}\nfunction sortWallets(wallets, preferredWallets, features) {\n  const suiWallets = wallets.filter(wallet => isWalletWithSuiFeatures(wallet, features));\n  return [\n  // Preferred wallets, in order:\n  ...preferredWallets.map(name => suiWallets.find(wallet => wallet.name === name)).filter(Boolean),\n  // Wallets in default order:\n  ...suiWallets.filter(wallet => !preferredWallets.includes(wallet.name))];\n}\nfunction createWalletKitCore({\n  preferredWallets = [SUI_WALLET_NAME],\n  storageAdapter = localStorageAdapter,\n  storageKey = RECENT_WALLET_STORAGE,\n  features = DEFAULT_FEATURES\n}) {\n  const registeredWallets = getWallets();\n  let wallets = registeredWallets.get();\n  const subscriptions = /* @__PURE__ */new Set();\n  let walletEventUnsubscribe = null;\n  let internalState = {\n    accounts: [],\n    currentAccount: null,\n    wallets: sortWallets(wallets, preferredWallets, features),\n    currentWallet: null,\n    status: \"DISCONNECTED\" /* DISCONNECTED */\n  };\n  const computeState = () => ({\n    ...internalState,\n    isConnecting: internalState.status === \"CONNECTING\" /* CONNECTING */,\n    isConnected: internalState.status === \"CONNECTED\" /* CONNECTED */,\n    isError: internalState.status === \"ERROR\" /* ERROR */\n  });\n  let state = computeState();\n  function setState(nextInternalState) {\n    internalState = {\n      ...internalState,\n      ...nextInternalState\n    };\n    state = computeState();\n    subscriptions.forEach(handler => {\n      try {\n        handler(state);\n      } catch {}\n    });\n  }\n  function disconnected() {\n    if (walletEventUnsubscribe) {\n      walletEventUnsubscribe();\n      walletEventUnsubscribe = null;\n    }\n    setState({\n      status: \"DISCONNECTED\" /* DISCONNECTED */,\n      accounts: [],\n      currentAccount: null,\n      currentWallet: null\n    });\n  }\n  const handleWalletsChanged = () => {\n    setState({\n      wallets: sortWallets(registeredWallets.get(), preferredWallets, features)\n    });\n  };\n  registeredWallets.on(\"register\", handleWalletsChanged);\n  registeredWallets.on(\"unregister\", handleWalletsChanged);\n  const walletKit = {\n    async autoconnect() {\n      if (state.currentWallet) return;\n      await waitToBeVisible();\n      try {\n        const lastWalletName = await storageAdapter.get(storageKey);\n        if (lastWalletName) {\n          walletKit.connect(lastWalletName, {\n            silent: true\n          });\n        }\n      } catch {}\n    },\n    getState() {\n      return state;\n    },\n    subscribe(handler) {\n      subscriptions.add(handler);\n      try {\n        handler(state);\n      } catch {}\n      return () => {\n        subscriptions.delete(handler);\n      };\n    },\n    selectAccount(account) {\n      if (account === internalState.currentAccount || !internalState.accounts.includes(account)) {\n        return;\n      }\n      setState({\n        currentAccount: account\n      });\n    },\n    async connect(walletName, connectInput) {\n      const currentWallet = internalState.wallets.find(wallet => wallet.name === walletName) ?? null;\n      setState({\n        currentWallet\n      });\n      if (currentWallet) {\n        if (walletEventUnsubscribe) {\n          walletEventUnsubscribe();\n        }\n        walletEventUnsubscribe = currentWallet.features[\"standard:events\"].on(\"change\", ({\n          accounts,\n          features: features2,\n          chains\n        }) => {\n          if (accounts) {\n            setState({\n              accounts,\n              currentAccount: internalState.currentAccount && !accounts.find(({\n                address\n              }) => address === internalState.currentAccount?.address) ? accounts[0] : internalState.currentAccount\n            });\n          }\n        });\n        try {\n          setState({\n            status: \"CONNECTING\" /* CONNECTING */\n          });\n          await currentWallet.features[\"standard:connect\"].connect(connectInput);\n          setState({\n            status: \"CONNECTED\" /* CONNECTED */\n          });\n          try {\n            await storageAdapter.set(storageKey, currentWallet.name);\n          } catch {}\n          setState({\n            accounts: currentWallet.accounts,\n            currentAccount: currentWallet.accounts[0] ?? null\n          });\n        } catch (e) {\n          console.log(\"Wallet connection error\", e);\n          setState({\n            status: \"ERROR\" /* ERROR */\n          });\n        }\n      } else {\n        setState({\n          status: \"DISCONNECTED\" /* DISCONNECTED */\n        });\n      }\n    },\n    async disconnect() {\n      if (!internalState.currentWallet) {\n        console.warn(\"Attempted to `disconnect` but no wallet was connected.\");\n        return;\n      }\n      try {\n        await storageAdapter.del(storageKey);\n      } catch {}\n      await internalState.currentWallet.features[\"standard:disconnect\"]?.disconnect();\n      disconnected();\n    },\n    /** @deprecated Use `signPersonalMessage` instead. */\n    signMessage(messageInput) {\n      if (!internalState.currentWallet || !internalState.currentAccount) {\n        throw new Error(\"No wallet is currently connected, cannot call `signMessage`.\");\n      }\n      if (!internalState.currentWallet.features[\"sui:signMessage\"]) {\n        throw new Error(\"Wallet does not support deprecated `signMessage` method.\");\n      }\n      return internalState.currentWallet.features[\"sui:signMessage\"].signMessage({\n        ...messageInput,\n        account: messageInput.account ?? internalState.currentAccount\n      });\n    },\n    signPersonalMessage(messageInput) {\n      if (!internalState.currentWallet || !internalState.currentAccount) {\n        throw new Error(\"No wallet is currently connected, cannot call `signPersonalMessage`.\");\n      }\n      if (!internalState.currentWallet.features[\"sui:signPersonalMessage\"]) {\n        throw new Error(\"Wallet does not support the new `signPersonalMessage` method.\");\n      }\n      return internalState.currentWallet.features[\"sui:signPersonalMessage\"].signPersonalMessage({\n        ...messageInput,\n        account: messageInput.account ?? internalState.currentAccount\n      });\n    },\n    async signTransactionBlock(transactionInput) {\n      if (!internalState.currentWallet || !internalState.currentAccount) {\n        throw new Error(\"No wallet is currently connected, cannot call `signTransaction`.\");\n      }\n      const {\n        account = internalState.currentAccount,\n        chain = internalState.currentAccount.chains[0]\n      } = transactionInput;\n      if (!chain) {\n        throw new Error(\"Missing chain\");\n      }\n      return internalState.currentWallet.features[\"sui:signTransactionBlock\"].signTransactionBlock({\n        ...transactionInput,\n        account,\n        chain\n      });\n    },\n    async signAndExecuteTransactionBlock(transactionInput) {\n      if (!internalState.currentWallet || !internalState.currentAccount) {\n        throw new Error(\"No wallet is currently connected, cannot call `signAndExecuteTransactionBlock`.\");\n      }\n      const {\n        account = internalState.currentAccount,\n        chain = internalState.currentAccount.chains[0]\n      } = transactionInput;\n      if (!chain) {\n        throw new Error(\"Missing chain\");\n      }\n      return internalState.currentWallet.features[\"sui:signAndExecuteTransactionBlock\"].signAndExecuteTransactionBlock({\n        ...transactionInput,\n        account,\n        chain\n      });\n    }\n  };\n  return walletKit;\n}\nexport { DEFAULT_FEATURES, WalletKitCoreConnectionStatus, createWalletKitCore, localStorageAdapter, noopStorageAdapter };","map":{"version":3,"names":["getWallets","isWalletWithSuiFeatures","localStorageAdapter","set","key","value","localStorage","setItem","get","getItem","del","removeItem","noopStorageAdapter","DEFAULT_FEATURES","WalletKitCoreConnectionStatus","WalletKitCoreConnectionStatus2","SUI_WALLET_NAME","RECENT_WALLET_STORAGE","waitToBeVisible","document","visibilityState","Promise","resolve","promiseResolve","promise","r","callback","removeEventListener","addEventListener","sortWallets","wallets","preferredWallets","features","suiWallets","filter","wallet","map","name","find","Boolean","includes","createWalletKitCore","storageAdapter","storageKey","registeredWallets","subscriptions","Set","walletEventUnsubscribe","internalState","accounts","currentAccount","currentWallet","status","computeState","isConnecting","isConnected","isError","state","setState","nextInternalState","forEach","handler","disconnected","handleWalletsChanged","on","walletKit","autoconnect","lastWalletName","connect","silent","getState","subscribe","add","delete","selectAccount","account","walletName","connectInput","features2","chains","address","e","console","log","disconnect","warn","signMessage","messageInput","Error","signPersonalMessage","signTransactionBlock","transactionInput","chain","signAndExecuteTransactionBlock"],"sources":["/home/andrei/proiect-itb/token/frontend/node_modules/@mysten/wallet-kit-core/src/index.ts","/home/andrei/proiect-itb/token/frontend/node_modules/@mysten/wallet-kit-core/src/storage.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n\tgetWallets,\n\tisWalletWithSuiFeatures,\n\tStandardConnectInput,\n\tSuiSignAndExecuteTransactionBlockInput,\n\tSuiSignAndExecuteTransactionBlockOutput,\n\tSuiSignMessageInput,\n\tSuiSignMessageOutput,\n\tSuiSignPersonalMessageInput,\n\tSuiSignPersonalMessageOutput,\n\tSuiSignTransactionBlockInput,\n\tSuiSignTransactionBlockOutput,\n\tWallet,\n\tWalletAccount,\n\tWalletWithSuiFeatures,\n} from '@mysten/wallet-standard';\n\nimport { localStorageAdapter, StorageAdapter } from './storage';\n\nexport * from './storage';\n\nexport const DEFAULT_FEATURES: (keyof WalletWithSuiFeatures['features'])[] = [\n\t'sui:signAndExecuteTransactionBlock',\n];\n\nexport interface WalletKitCoreOptions {\n\tpreferredWallets?: string[];\n\tstorageAdapter?: StorageAdapter;\n\tstorageKey?: string;\n\tfeatures?: string[];\n}\n\nexport enum WalletKitCoreConnectionStatus {\n\tDISCONNECTED = 'DISCONNECTED',\n\tCONNECTING = 'CONNECTING',\n\tCONNECTED = 'CONNECTED',\n\t// TODO: Figure out if this is really a separate status, or is just a piece of state alongside the `disconnected` state:\n\tERROR = 'ERROR',\n}\n\nexport interface InternalWalletKitCoreState {\n\twallets: WalletWithSuiFeatures[];\n\tcurrentWallet: WalletWithSuiFeatures | null;\n\taccounts: readonly WalletAccount[];\n\tcurrentAccount: WalletAccount | null;\n\tstatus: WalletKitCoreConnectionStatus;\n}\n\nexport interface WalletKitCoreState extends InternalWalletKitCoreState {\n\tisConnecting: boolean;\n\tisConnected: boolean;\n\tisError: boolean;\n}\n\ntype OptionalProperties<T extends Record<any, any>, U extends keyof T> = Omit<T, U> &\n\tPartial<Pick<T, U>>;\n\nexport interface WalletKitCore {\n\tautoconnect(): Promise<void>;\n\tgetState(): WalletKitCoreState;\n\tsubscribe(handler: SubscribeHandler): Unsubscribe;\n\tconnect(walletName: string, connectInput?: StandardConnectInput): Promise<void>;\n\tselectAccount(account: WalletAccount): void;\n\tdisconnect(): Promise<void>;\n\t/** @deprecated Use `signPersonalMessage` instead. */\n\tsignMessage(\n\t\tmessageInput: OptionalProperties<SuiSignMessageInput, 'account'>,\n\t): Promise<SuiSignMessageOutput>;\n\tsignPersonalMessage(\n\t\tmessageInput: OptionalProperties<SuiSignPersonalMessageInput, 'account'>,\n\t): Promise<SuiSignPersonalMessageOutput>;\n\tsignTransactionBlock: (\n\t\ttransactionInput: OptionalProperties<SuiSignTransactionBlockInput, 'chain' | 'account'>,\n\t) => Promise<SuiSignTransactionBlockOutput>;\n\tsignAndExecuteTransactionBlock: (\n\t\ttransactionInput: OptionalProperties<\n\t\t\tSuiSignAndExecuteTransactionBlockInput,\n\t\t\t'chain' | 'account'\n\t\t>,\n\t) => Promise<SuiSignAndExecuteTransactionBlockOutput>;\n}\n\nexport type SubscribeHandler = (state: WalletKitCoreState) => void;\nexport type Unsubscribe = () => void;\n\nconst SUI_WALLET_NAME = 'Sui Wallet';\n\nconst RECENT_WALLET_STORAGE = 'wallet-kit:last-wallet';\n\nfunction waitToBeVisible() {\n\tif (!document || document.visibilityState === 'visible') {\n\t\treturn Promise.resolve();\n\t}\n\tlet promiseResolve: (() => void) | null = null;\n\tconst promise = new Promise<void>((r) => (promiseResolve = r));\n\tconst callback = () => {\n\t\tif (promiseResolve && document.visibilityState === 'visible') {\n\t\t\tpromiseResolve();\n\t\t\tdocument.removeEventListener('visibilitychange', callback);\n\t\t}\n\t};\n\tdocument.addEventListener('visibilitychange', callback);\n\treturn promise;\n}\n\nfunction sortWallets(\n\twallets: readonly Wallet[],\n\tpreferredWallets: string[],\n\tfeatures?: string[],\n): WalletWithSuiFeatures[] {\n\tconst suiWallets = wallets.filter((wallet) =>\n\t\tisWalletWithSuiFeatures(wallet, features),\n\t) as WalletWithSuiFeatures[];\n\n\treturn [\n\t\t// Preferred wallets, in order:\n\t\t...(preferredWallets\n\t\t\t.map((name) => suiWallets.find((wallet) => wallet.name === name))\n\t\t\t.filter(Boolean) as WalletWithSuiFeatures[]),\n\n\t\t// Wallets in default order:\n\t\t...suiWallets.filter((wallet) => !preferredWallets.includes(wallet.name)),\n\t];\n}\n\nexport function createWalletKitCore({\n\tpreferredWallets = [SUI_WALLET_NAME],\n\tstorageAdapter = localStorageAdapter,\n\tstorageKey = RECENT_WALLET_STORAGE,\n\tfeatures = DEFAULT_FEATURES,\n}: WalletKitCoreOptions): WalletKitCore {\n\tconst registeredWallets = getWallets();\n\tlet wallets = registeredWallets.get();\n\n\tconst subscriptions: Set<(state: WalletKitCoreState) => void> = new Set();\n\tlet walletEventUnsubscribe: (() => void) | null = null;\n\n\tlet internalState: InternalWalletKitCoreState = {\n\t\taccounts: [],\n\t\tcurrentAccount: null,\n\t\twallets: sortWallets(wallets, preferredWallets, features),\n\t\tcurrentWallet: null,\n\t\tstatus: WalletKitCoreConnectionStatus.DISCONNECTED,\n\t};\n\n\tconst computeState = () => ({\n\t\t...internalState,\n\t\tisConnecting: internalState.status === WalletKitCoreConnectionStatus.CONNECTING,\n\t\tisConnected: internalState.status === WalletKitCoreConnectionStatus.CONNECTED,\n\t\tisError: internalState.status === WalletKitCoreConnectionStatus.ERROR,\n\t});\n\n\tlet state = computeState();\n\n\tfunction setState(nextInternalState: Partial<InternalWalletKitCoreState>) {\n\t\tinternalState = {\n\t\t\t...internalState,\n\t\t\t...nextInternalState,\n\t\t};\n\t\tstate = computeState();\n\t\tsubscriptions.forEach((handler) => {\n\t\t\ttry {\n\t\t\t\thandler(state);\n\t\t\t} catch {\n\t\t\t\t/* ignore error */\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction disconnected() {\n\t\tif (walletEventUnsubscribe) {\n\t\t\twalletEventUnsubscribe();\n\t\t\twalletEventUnsubscribe = null;\n\t\t}\n\t\tsetState({\n\t\t\tstatus: WalletKitCoreConnectionStatus.DISCONNECTED,\n\t\t\taccounts: [],\n\t\t\tcurrentAccount: null,\n\t\t\tcurrentWallet: null,\n\t\t});\n\t}\n\n\tconst handleWalletsChanged = () => {\n\t\tsetState({\n\t\t\twallets: sortWallets(registeredWallets.get(), preferredWallets, features),\n\t\t});\n\t};\n\n\tregisteredWallets.on('register', handleWalletsChanged);\n\tregisteredWallets.on('unregister', handleWalletsChanged);\n\n\tconst walletKit: WalletKitCore = {\n\t\tasync autoconnect() {\n\t\t\tif (state.currentWallet) return;\n\t\t\tawait waitToBeVisible();\n\t\t\ttry {\n\t\t\t\tconst lastWalletName = await storageAdapter.get(storageKey);\n\t\t\t\tif (lastWalletName) {\n\t\t\t\t\twalletKit.connect(lastWalletName, { silent: true });\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t/* ignore error */\n\t\t\t}\n\t\t},\n\n\t\tgetState() {\n\t\t\treturn state;\n\t\t},\n\n\t\tsubscribe(handler) {\n\t\t\tsubscriptions.add(handler);\n\n\t\t\t// Immediately invoke the handler with the current state to make it compatible with Svelte stores:\n\t\t\ttry {\n\t\t\t\thandler(state);\n\t\t\t} catch {\n\t\t\t\t/* ignore error */\n\t\t\t}\n\n\t\t\treturn () => {\n\t\t\t\tsubscriptions.delete(handler);\n\t\t\t};\n\t\t},\n\n\t\tselectAccount(account) {\n\t\t\tif (account === internalState.currentAccount || !internalState.accounts.includes(account)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tsetState({\n\t\t\t\tcurrentAccount: account,\n\t\t\t});\n\t\t},\n\n\t\tasync connect(walletName, connectInput) {\n\t\t\tconst currentWallet =\n\t\t\t\tinternalState.wallets.find((wallet) => wallet.name === walletName) ?? null;\n\n\t\t\t// TODO: Should the current wallet actually be set before we successfully connect to it?\n\t\t\tsetState({ currentWallet });\n\n\t\t\tif (currentWallet) {\n\t\t\t\tif (walletEventUnsubscribe) {\n\t\t\t\t\twalletEventUnsubscribe();\n\t\t\t\t}\n\t\t\t\twalletEventUnsubscribe = currentWallet.features['standard:events'].on(\n\t\t\t\t\t'change',\n\t\t\t\t\t({ accounts, features, chains }) => {\n\t\t\t\t\t\t// TODO: Handle features or chains changing.\n\t\t\t\t\t\tif (accounts) {\n\t\t\t\t\t\t\tsetState({\n\t\t\t\t\t\t\t\taccounts,\n\t\t\t\t\t\t\t\tcurrentAccount:\n\t\t\t\t\t\t\t\t\tinternalState.currentAccount &&\n\t\t\t\t\t\t\t\t\t!accounts.find(({ address }) => address === internalState.currentAccount?.address)\n\t\t\t\t\t\t\t\t\t\t? accounts[0]\n\t\t\t\t\t\t\t\t\t\t: internalState.currentAccount,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\ttry {\n\t\t\t\t\tsetState({ status: WalletKitCoreConnectionStatus.CONNECTING });\n\t\t\t\t\tawait currentWallet.features['standard:connect'].connect(connectInput);\n\t\t\t\t\tsetState({ status: WalletKitCoreConnectionStatus.CONNECTED });\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait storageAdapter.set(storageKey, currentWallet.name);\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t/* ignore error */\n\t\t\t\t\t}\n\n\t\t\t\t\tsetState({\n\t\t\t\t\t\taccounts: currentWallet.accounts,\n\t\t\t\t\t\tcurrentAccount: currentWallet.accounts[0] ?? null,\n\t\t\t\t\t});\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.log('Wallet connection error', e);\n\n\t\t\t\t\tsetState({ status: WalletKitCoreConnectionStatus.ERROR });\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsetState({ status: WalletKitCoreConnectionStatus.DISCONNECTED });\n\t\t\t}\n\t\t},\n\n\t\tasync disconnect() {\n\t\t\tif (!internalState.currentWallet) {\n\t\t\t\tconsole.warn('Attempted to `disconnect` but no wallet was connected.');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tawait storageAdapter.del(storageKey);\n\t\t\t} catch {\n\t\t\t\t/* ignore error */\n\t\t\t}\n\t\t\tawait internalState.currentWallet.features['standard:disconnect']?.disconnect();\n\t\t\tdisconnected();\n\t\t},\n\n\t\t/** @deprecated Use `signPersonalMessage` instead. */\n\t\tsignMessage(messageInput) {\n\t\t\tif (!internalState.currentWallet || !internalState.currentAccount) {\n\t\t\t\tthrow new Error('No wallet is currently connected, cannot call `signMessage`.');\n\t\t\t}\n\n\t\t\tif (!internalState.currentWallet.features['sui:signMessage']) {\n\t\t\t\tthrow new Error('Wallet does not support deprecated `signMessage` method.');\n\t\t\t}\n\n\t\t\treturn internalState.currentWallet.features['sui:signMessage'].signMessage({\n\t\t\t\t...messageInput,\n\t\t\t\taccount: messageInput.account ?? internalState.currentAccount,\n\t\t\t});\n\t\t},\n\n\t\tsignPersonalMessage(messageInput) {\n\t\t\tif (!internalState.currentWallet || !internalState.currentAccount) {\n\t\t\t\tthrow new Error('No wallet is currently connected, cannot call `signPersonalMessage`.');\n\t\t\t}\n\n\t\t\tif (!internalState.currentWallet.features['sui:signPersonalMessage']) {\n\t\t\t\tthrow new Error('Wallet does not support the new `signPersonalMessage` method.');\n\t\t\t}\n\n\t\t\treturn internalState.currentWallet.features['sui:signPersonalMessage'].signPersonalMessage({\n\t\t\t\t...messageInput,\n\t\t\t\taccount: messageInput.account ?? internalState.currentAccount,\n\t\t\t});\n\t\t},\n\n\t\tasync signTransactionBlock(transactionInput) {\n\t\t\tif (!internalState.currentWallet || !internalState.currentAccount) {\n\t\t\t\tthrow new Error('No wallet is currently connected, cannot call `signTransaction`.');\n\t\t\t}\n\t\t\tconst {\n\t\t\t\taccount = internalState.currentAccount,\n\t\t\t\tchain = internalState.currentAccount.chains[0],\n\t\t\t} = transactionInput;\n\t\t\tif (!chain) {\n\t\t\t\tthrow new Error('Missing chain');\n\t\t\t}\n\t\t\treturn internalState.currentWallet.features['sui:signTransactionBlock'].signTransactionBlock({\n\t\t\t\t...transactionInput,\n\t\t\t\taccount,\n\t\t\t\tchain,\n\t\t\t});\n\t\t},\n\n\t\tasync signAndExecuteTransactionBlock(transactionInput) {\n\t\t\tif (!internalState.currentWallet || !internalState.currentAccount) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'No wallet is currently connected, cannot call `signAndExecuteTransactionBlock`.',\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst {\n\t\t\t\taccount = internalState.currentAccount,\n\t\t\t\tchain = internalState.currentAccount.chains[0],\n\t\t\t} = transactionInput;\n\n\t\t\tif (!chain) {\n\t\t\t\tthrow new Error('Missing chain');\n\t\t\t}\n\n\t\t\treturn internalState.currentWallet.features[\n\t\t\t\t'sui:signAndExecuteTransactionBlock'\n\t\t\t].signAndExecuteTransactionBlock({\n\t\t\t\t...transactionInput,\n\t\t\t\taccount,\n\t\t\t\tchain,\n\t\t\t});\n\t\t},\n\t};\n\n\treturn walletKit;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport interface StorageAdapter {\n\tset(key: string, value: string): Promise<void>;\n\tget(key: string): Promise<string | undefined | null>;\n\tdel(key: string): Promise<void>;\n}\n\nexport const localStorageAdapter: StorageAdapter = {\n\tasync set(key, value) {\n\t\treturn localStorage.setItem(key, value);\n\t},\n\tasync get(key) {\n\t\treturn localStorage.getItem(key);\n\t},\n\tasync del(key) {\n\t\tlocalStorage.removeItem(key);\n\t},\n};\n\nexport const noopStorageAdapter: StorageAdapter = {\n\tasync set() {},\n\tasync get() {\n\t\treturn null;\n\t},\n\tasync del() {},\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}