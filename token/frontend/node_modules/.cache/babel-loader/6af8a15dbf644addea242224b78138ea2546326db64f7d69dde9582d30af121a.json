{"ast":null,"code":"import { toB58 } from \"@mysten/bcs\";\nimport { array, assert, define, integer, is, literal, nullable, object, optional, string, union } from \"superstruct\";\nimport { bcs } from \"../bcs/index.js\";\nimport { SuiObjectRef } from \"../types/index.js\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nimport { hashTypedData } from \"./hash.js\";\nimport { BuilderCallArg, PureCallArg } from \"./Inputs.js\";\nimport { TransactionBlockInput, TransactionType } from \"./Transactions.js\";\nimport { create } from \"./utils.js\";\nconst TransactionExpiration = optional(nullable(union([object({\n  Epoch: integer()\n}), object({\n  None: union([literal(true), literal(null)])\n})])));\nconst StringEncodedBigint = define(\"StringEncodedBigint\", val => {\n  if (![\"string\", \"number\", \"bigint\"].includes(typeof val)) return false;\n  try {\n    BigInt(val);\n    return true;\n  } catch {\n    return false;\n  }\n});\nconst GasConfig = object({\n  budget: optional(StringEncodedBigint),\n  price: optional(StringEncodedBigint),\n  payment: optional(array(SuiObjectRef)),\n  owner: optional(string())\n});\nconst SerializedTransactionDataBuilder = object({\n  version: literal(1),\n  sender: optional(string()),\n  expiration: TransactionExpiration,\n  gasConfig: GasConfig,\n  inputs: array(TransactionBlockInput),\n  transactions: array(TransactionType)\n});\nfunction prepareSuiAddress(address) {\n  return normalizeSuiAddress(address).replace(\"0x\", \"\");\n}\nclass TransactionBlockDataBuilder {\n  constructor(clone) {\n    this.version = 1;\n    this.sender = clone?.sender;\n    this.expiration = clone?.expiration;\n    this.gasConfig = clone?.gasConfig ?? {};\n    this.inputs = clone?.inputs ?? [];\n    this.transactions = clone?.transactions ?? [];\n  }\n  static fromKindBytes(bytes) {\n    const kind = bcs.TransactionKind.parse(bytes);\n    const programmableTx = \"ProgrammableTransaction\" in kind ? kind.ProgrammableTransaction : null;\n    if (!programmableTx) {\n      throw new Error(\"Unable to deserialize from bytes.\");\n    }\n    const serialized = create({\n      version: 1,\n      gasConfig: {},\n      inputs: programmableTx.inputs.map((value, index) => create({\n        kind: \"Input\",\n        value,\n        index,\n        type: is(value, PureCallArg) ? \"pure\" : \"object\"\n      }, TransactionBlockInput)),\n      transactions: programmableTx.transactions\n    }, SerializedTransactionDataBuilder);\n    return TransactionBlockDataBuilder.restore(serialized);\n  }\n  static fromBytes(bytes) {\n    const rawData = bcs.TransactionData.parse(bytes);\n    const data = rawData?.V1;\n    const programmableTx = \"ProgrammableTransaction\" in data.kind ? data?.kind?.ProgrammableTransaction : null;\n    if (!data || !programmableTx) {\n      throw new Error(\"Unable to deserialize from bytes.\");\n    }\n    const serialized = create({\n      version: 1,\n      sender: data.sender,\n      expiration: data.expiration,\n      gasConfig: data.gasData,\n      inputs: programmableTx.inputs.map((value, index) => create({\n        kind: \"Input\",\n        value,\n        index,\n        type: is(value, PureCallArg) ? \"pure\" : \"object\"\n      }, TransactionBlockInput)),\n      transactions: programmableTx.transactions\n    }, SerializedTransactionDataBuilder);\n    return TransactionBlockDataBuilder.restore(serialized);\n  }\n  static restore(data) {\n    assert(data, SerializedTransactionDataBuilder);\n    const transactionData = new TransactionBlockDataBuilder();\n    Object.assign(transactionData, data);\n    return transactionData;\n  }\n  /**\n   * Generate transaction digest.\n   *\n   * @param bytes BCS serialized transaction data\n   * @returns transaction digest.\n   */\n  static getDigestFromBytes(bytes) {\n    const hash = hashTypedData(\"TransactionData\", bytes);\n    return toB58(hash);\n  }\n  build({\n    maxSizeBytes = Infinity,\n    overrides,\n    onlyTransactionKind\n  } = {}) {\n    const inputs = this.inputs.map(input => {\n      assert(input.value, BuilderCallArg);\n      return input.value;\n    });\n    const kind = {\n      ProgrammableTransaction: {\n        inputs,\n        transactions: this.transactions\n      }\n    };\n    if (onlyTransactionKind) {\n      return bcs.TransactionKind.serialize(kind, {\n        maxSize: maxSizeBytes\n      }).toBytes();\n    }\n    const expiration = overrides?.expiration ?? this.expiration;\n    const sender = overrides?.sender ?? this.sender;\n    const gasConfig = {\n      ...this.gasConfig,\n      ...overrides?.gasConfig\n    };\n    if (!sender) {\n      throw new Error(\"Missing transaction sender\");\n    }\n    if (!gasConfig.budget) {\n      throw new Error(\"Missing gas budget\");\n    }\n    if (!gasConfig.payment) {\n      throw new Error(\"Missing gas payment\");\n    }\n    if (!gasConfig.price) {\n      throw new Error(\"Missing gas price\");\n    }\n    const transactionData = {\n      sender: prepareSuiAddress(sender),\n      expiration: expiration ? expiration : {\n        None: true\n      },\n      gasData: {\n        payment: gasConfig.payment,\n        owner: prepareSuiAddress(this.gasConfig.owner ?? sender),\n        price: BigInt(gasConfig.price),\n        budget: BigInt(gasConfig.budget)\n      },\n      kind: {\n        ProgrammableTransaction: {\n          inputs,\n          transactions: this.transactions\n        }\n      }\n    };\n    return bcs.TransactionData.serialize({\n      V1: transactionData\n    }, {\n      maxSize: maxSizeBytes\n    }).toBytes();\n  }\n  getDigest() {\n    const bytes = this.build({\n      onlyTransactionKind: false\n    });\n    return TransactionBlockDataBuilder.getDigestFromBytes(bytes);\n  }\n  snapshot() {\n    return create(this, SerializedTransactionDataBuilder);\n  }\n}\nexport { SerializedTransactionDataBuilder, TransactionBlockDataBuilder, TransactionExpiration };","map":{"version":3,"names":["toB58","array","assert","define","integer","is","literal","nullable","object","optional","string","union","bcs","SuiObjectRef","normalizeSuiAddress","hashTypedData","BuilderCallArg","PureCallArg","TransactionBlockInput","TransactionType","create","TransactionExpiration","Epoch","None","StringEncodedBigint","val","includes","BigInt","GasConfig","budget","price","payment","owner","SerializedTransactionDataBuilder","version","sender","expiration","gasConfig","inputs","transactions","prepareSuiAddress","address","replace","TransactionBlockDataBuilder","constructor","clone","fromKindBytes","bytes","kind","TransactionKind","parse","programmableTx","ProgrammableTransaction","Error","serialized","map","value","index","type","restore","fromBytes","rawData","TransactionData","data","V1","gasData","transactionData","Object","assign","getDigestFromBytes","hash","build","maxSizeBytes","Infinity","overrides","onlyTransactionKind","input","serialize","maxSize","toBytes","getDigest","snapshot"],"sources":["/home/andrei/proiect-itb/token/frontend/node_modules/@mysten/sui.js/src/builder/TransactionBlockData.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB58 } from '@mysten/bcs';\nimport type { Infer } from 'superstruct';\nimport {\n\tarray,\n\tassert,\n\tdefine,\n\tinteger,\n\tis,\n\tliteral,\n\tnullable,\n\tobject,\n\toptional,\n\tstring,\n\tunion,\n} from 'superstruct';\n\nimport { bcs } from '../bcs/index.js';\nimport { SuiObjectRef } from '../types/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport { hashTypedData } from './hash.js';\nimport { BuilderCallArg, PureCallArg } from './Inputs.js';\nimport { TransactionBlockInput, TransactionType } from './Transactions.js';\nimport { create } from './utils.js';\n\nexport const TransactionExpiration = optional(\n\tnullable(\n\t\tunion([object({ Epoch: integer() }), object({ None: union([literal(true), literal(null)]) })]),\n\t),\n);\nexport type TransactionExpiration = Infer<typeof TransactionExpiration>;\n\nconst StringEncodedBigint = define<string | number | bigint>('StringEncodedBigint', (val) => {\n\tif (!['string', 'number', 'bigint'].includes(typeof val)) return false;\n\n\ttry {\n\t\tBigInt(val as string);\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n});\n\nconst GasConfig = object({\n\tbudget: optional(StringEncodedBigint),\n\tprice: optional(StringEncodedBigint),\n\tpayment: optional(array(SuiObjectRef)),\n\towner: optional(string()),\n});\ntype GasConfig = Infer<typeof GasConfig>;\n\nexport const SerializedTransactionDataBuilder = object({\n\tversion: literal(1),\n\tsender: optional(string()),\n\texpiration: TransactionExpiration,\n\tgasConfig: GasConfig,\n\tinputs: array(TransactionBlockInput),\n\ttransactions: array(TransactionType),\n});\nexport type SerializedTransactionDataBuilder = Infer<typeof SerializedTransactionDataBuilder>;\n\nfunction prepareSuiAddress(address: string) {\n\treturn normalizeSuiAddress(address).replace('0x', '');\n}\n\nexport class TransactionBlockDataBuilder {\n\tstatic fromKindBytes(bytes: Uint8Array) {\n\t\tconst kind = bcs.TransactionKind.parse(bytes);\n\t\tconst programmableTx = 'ProgrammableTransaction' in kind ? kind.ProgrammableTransaction : null;\n\t\tif (!programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\tconst serialized = create(\n\t\t\t{\n\t\t\t\tversion: 1,\n\t\t\t\tgasConfig: {},\n\t\t\t\tinputs: programmableTx.inputs.map((value: unknown, index: number) =>\n\t\t\t\t\tcreate(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tkind: 'Input',\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\ttype: is(value, PureCallArg) ? 'pure' : 'object',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tTransactionBlockInput,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\ttransactions: programmableTx.transactions,\n\t\t\t},\n\t\t\tSerializedTransactionDataBuilder,\n\t\t);\n\n\t\treturn TransactionBlockDataBuilder.restore(serialized);\n\t}\n\n\tstatic fromBytes(bytes: Uint8Array) {\n\t\tconst rawData = bcs.TransactionData.parse(bytes);\n\t\tconst data = rawData?.V1;\n\t\tconst programmableTx =\n\t\t\t'ProgrammableTransaction' in data.kind ? data?.kind?.ProgrammableTransaction : null;\n\t\tif (!data || !programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\tconst serialized = create(\n\t\t\t{\n\t\t\t\tversion: 1,\n\t\t\t\tsender: data.sender,\n\t\t\t\texpiration: data.expiration,\n\t\t\t\tgasConfig: data.gasData,\n\t\t\t\tinputs: programmableTx.inputs.map((value: unknown, index: number) =>\n\t\t\t\t\tcreate(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tkind: 'Input',\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\ttype: is(value, PureCallArg) ? 'pure' : 'object',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tTransactionBlockInput,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\ttransactions: programmableTx.transactions,\n\t\t\t},\n\t\t\tSerializedTransactionDataBuilder,\n\t\t);\n\n\t\treturn TransactionBlockDataBuilder.restore(serialized);\n\t}\n\n\tstatic restore(data: SerializedTransactionDataBuilder) {\n\t\tassert(data, SerializedTransactionDataBuilder);\n\t\tconst transactionData = new TransactionBlockDataBuilder();\n\t\tObject.assign(transactionData, data);\n\t\treturn transactionData;\n\t}\n\n\t/**\n\t * Generate transaction digest.\n\t *\n\t * @param bytes BCS serialized transaction data\n\t * @returns transaction digest.\n\t */\n\tstatic getDigestFromBytes(bytes: Uint8Array) {\n\t\tconst hash = hashTypedData('TransactionData', bytes);\n\t\treturn toB58(hash);\n\t}\n\n\tversion = 1 as const;\n\tsender?: string;\n\texpiration?: TransactionExpiration;\n\tgasConfig: GasConfig;\n\tinputs: TransactionBlockInput[];\n\ttransactions: TransactionType[];\n\n\tconstructor(clone?: SerializedTransactionDataBuilder) {\n\t\tthis.sender = clone?.sender;\n\t\tthis.expiration = clone?.expiration;\n\t\tthis.gasConfig = clone?.gasConfig ?? {};\n\t\tthis.inputs = clone?.inputs ?? [];\n\t\tthis.transactions = clone?.transactions ?? [];\n\t}\n\n\tbuild({\n\t\tmaxSizeBytes = Infinity,\n\t\toverrides,\n\t\tonlyTransactionKind,\n\t}: {\n\t\tmaxSizeBytes?: number;\n\t\toverrides?: Pick<Partial<TransactionBlockDataBuilder>, 'sender' | 'gasConfig' | 'expiration'>;\n\t\tonlyTransactionKind?: boolean;\n\t} = {}) {\n\t\t// Resolve inputs down to values:\n\t\tconst inputs = this.inputs.map((input) => {\n\t\t\tassert(input.value, BuilderCallArg);\n\t\t\treturn input.value;\n\t\t});\n\n\t\tconst kind = {\n\t\t\tProgrammableTransaction: {\n\t\t\t\tinputs,\n\t\t\t\ttransactions: this.transactions,\n\t\t\t},\n\t\t};\n\n\t\tif (onlyTransactionKind) {\n\t\t\treturn bcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();\n\t\t}\n\n\t\tconst expiration = overrides?.expiration ?? this.expiration;\n\t\tconst sender = overrides?.sender ?? this.sender;\n\t\tconst gasConfig = { ...this.gasConfig, ...overrides?.gasConfig };\n\n\t\tif (!sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tif (!gasConfig.budget) {\n\t\t\tthrow new Error('Missing gas budget');\n\t\t}\n\n\t\tif (!gasConfig.payment) {\n\t\t\tthrow new Error('Missing gas payment');\n\t\t}\n\n\t\tif (!gasConfig.price) {\n\t\t\tthrow new Error('Missing gas price');\n\t\t}\n\n\t\tconst transactionData = {\n\t\t\tsender: prepareSuiAddress(sender),\n\t\t\texpiration: expiration ? expiration : { None: true },\n\t\t\tgasData: {\n\t\t\t\tpayment: gasConfig.payment,\n\t\t\t\towner: prepareSuiAddress(this.gasConfig.owner ?? sender),\n\t\t\t\tprice: BigInt(gasConfig.price),\n\t\t\t\tbudget: BigInt(gasConfig.budget),\n\t\t\t},\n\t\t\tkind: {\n\t\t\t\tProgrammableTransaction: {\n\t\t\t\t\tinputs,\n\t\t\t\t\ttransactions: this.transactions,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\treturn bcs.TransactionData.serialize(\n\t\t\t{ V1: transactionData },\n\t\t\t{ maxSize: maxSizeBytes },\n\t\t).toBytes();\n\t}\n\n\tgetDigest() {\n\t\tconst bytes = this.build({ onlyTransactionKind: false });\n\t\treturn TransactionBlockDataBuilder.getDigestFromBytes(bytes);\n\t}\n\n\tsnapshot(): SerializedTransactionDataBuilder {\n\t\treturn create(this, SerializedTransactionDataBuilder);\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}