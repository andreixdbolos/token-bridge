{"ast":null,"code":"var __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _blockData, _input, input_fn, _normalizeTransactionArgument, normalizeTransactionArgument_fn, _getConfig, getConfig_fn, _validate, validate_fn, _prepareGasPayment, prepareGasPayment_fn, _prepareGasPrice, prepareGasPrice_fn, _prepareTransactions, prepareTransactions_fn, _prepare, prepare_fn;\nimport { fromB64, isSerializedBcs } from \"@mysten/bcs\";\nimport { is, mask } from \"superstruct\";\nimport { bcs } from \"../bcs/index.js\";\nimport { extractMutableReference, extractReference, extractStructTag, getObjectReference, SuiObjectRef } from \"../types/index.js\";\nimport { SUI_TYPE_ARG } from \"../utils/index.js\";\nimport { normalizeSuiAddress, normalizeSuiObjectId } from \"../utils/sui-types.js\";\nimport { BuilderCallArg, getIdFromCallArg, Inputs, isMutableSharedObjectInput, PureCallArg } from \"./Inputs.js\";\nimport { createPure } from \"./pure.js\";\nimport { getPureSerializationType, isTxContext } from \"./serializer.js\";\nimport { TransactionBlockDataBuilder } from \"./TransactionBlockData.js\";\nimport { TransactionBlockInput, Transactions } from \"./Transactions.js\";\nimport { create } from \"./utils.js\";\nconst DefaultOfflineLimits = {\n  maxPureArgumentSize: 16 * 1024,\n  maxTxGas: 5e10,\n  maxGasObjects: 256,\n  maxTxSizeBytes: 128 * 1024\n};\nfunction createTransactionResult(index) {\n  const baseResult = {\n    kind: \"Result\",\n    index\n  };\n  const nestedResults = [];\n  const nestedResultFor = resultIndex => nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {\n    kind: \"NestedResult\",\n    index,\n    resultIndex\n  });\n  return new Proxy(baseResult, {\n    set() {\n      throw new Error(\"The transaction result is a proxy, and does not support setting properties directly\");\n    },\n    // TODO: Instead of making this return a concrete argument, we should ideally\n    // make it reference-based (so that this gets resolved at build-time), which\n    // allows re-ordering transactions.\n    get(target, property) {\n      if (property in target) {\n        return Reflect.get(target, property);\n      }\n      if (property === Symbol.iterator) {\n        return function* () {\n          let i = 0;\n          while (true) {\n            yield nestedResultFor(i);\n            i++;\n          }\n        };\n      }\n      if (typeof property === \"symbol\") return;\n      const resultIndex = parseInt(property, 10);\n      if (Number.isNaN(resultIndex) || resultIndex < 0) return;\n      return nestedResultFor(resultIndex);\n    }\n  });\n}\nfunction isReceivingType(normalizedType) {\n  const tag = extractStructTag(normalizedType);\n  if (tag) {\n    return tag.Struct.address === \"0x2\" && tag.Struct.module === \"transfer\" && tag.Struct.name === \"Receiving\";\n  }\n  return false;\n}\nfunction expectClient(options) {\n  if (!options.client) {\n    throw new Error(`No provider passed to Transaction#build, but transaction data was not sufficient to build offline.`);\n  }\n  return options.client;\n}\nconst TRANSACTION_BRAND = Symbol.for(\"@mysten/transaction\");\nconst LIMITS = {\n  // The maximum gas that is allowed.\n  maxTxGas: \"max_tx_gas\",\n  // The maximum number of gas objects that can be selected for one transaction.\n  maxGasObjects: \"max_gas_payment_objects\",\n  // The maximum size (in bytes) that the transaction can be:\n  maxTxSizeBytes: \"max_tx_size_bytes\",\n  // The maximum size (in bytes) that pure arguments can be:\n  maxPureArgumentSize: \"max_pure_argument_size\"\n};\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_OBJECTS_PER_FETCH = 50;\nconst chunk = (arr, size) => Array.from({\n  length: Math.ceil(arr.length / size)\n}, (_, i) => arr.slice(i * size, i * size + size));\nfunction isTransactionBlock(obj) {\n  return !!obj && typeof obj === \"object\" && obj[TRANSACTION_BRAND] === true;\n}\nconst _TransactionBlock = class {\n  constructor(transaction) {\n    /**\n     * Dynamically create a new input, which is separate from the `input`. This is important\n     * for generated clients to be able to define unique inputs that are non-overlapping with the\n     * defined inputs.\n     *\n     * For `Uint8Array` type automatically convert the input into a `Pure` CallArg, since this\n     * is the format required for custom serialization.\n     *\n     */\n    __privateAdd(this, _input);\n    __privateAdd(this, _normalizeTransactionArgument);\n    __privateAdd(this, _getConfig);\n    __privateAdd(this, _validate);\n    // The current default is just picking _all_ coins we can which may not be ideal.\n    __privateAdd(this, _prepareGasPayment);\n    __privateAdd(this, _prepareGasPrice);\n    __privateAdd(this, _prepareTransactions);\n    /**\n     * Prepare the transaction by valdiating the transaction data and resolving all inputs\n     * so that it can be built into bytes.\n     */\n    __privateAdd(this, _prepare);\n    __privateAdd(this, _blockData, void 0);\n    __privateSet(this, _blockData, new TransactionBlockDataBuilder(transaction ? transaction.blockData : void 0));\n  }\n  /**\n   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n   * Supports either a byte array, or base64-encoded bytes.\n   */\n  static fromKind(serialized) {\n    const tx = new _TransactionBlock();\n    __privateSet(tx, _blockData, TransactionBlockDataBuilder.fromKindBytes(typeof serialized === \"string\" ? fromB64(serialized) : serialized));\n    return tx;\n  }\n  /**\n   * Converts from a serialized transaction format to a `Transaction` class.\n   * There are two supported serialized formats:\n   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n   * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n   */\n  static from(serialized) {\n    const tx = new _TransactionBlock();\n    if (typeof serialized !== \"string\" || !serialized.startsWith(\"{\")) {\n      __privateSet(tx, _blockData, TransactionBlockDataBuilder.fromBytes(typeof serialized === \"string\" ? fromB64(serialized) : serialized));\n    } else {\n      __privateSet(tx, _blockData, TransactionBlockDataBuilder.restore(JSON.parse(serialized)));\n    }\n    return tx;\n  }\n  setSender(sender) {\n    __privateGet(this, _blockData).sender = sender;\n  }\n  /**\n   * Sets the sender only if it has not already been set.\n   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n   */\n  setSenderIfNotSet(sender) {\n    if (!__privateGet(this, _blockData).sender) {\n      __privateGet(this, _blockData).sender = sender;\n    }\n  }\n  setExpiration(expiration) {\n    __privateGet(this, _blockData).expiration = expiration;\n  }\n  setGasPrice(price) {\n    __privateGet(this, _blockData).gasConfig.price = String(price);\n  }\n  setGasBudget(budget) {\n    __privateGet(this, _blockData).gasConfig.budget = String(budget);\n  }\n  setGasOwner(owner) {\n    __privateGet(this, _blockData).gasConfig.owner = owner;\n  }\n  setGasPayment(payments) {\n    __privateGet(this, _blockData).gasConfig.payment = payments.map(payment => mask(payment, SuiObjectRef));\n  }\n  /** Get a snapshot of the transaction data, in JSON form: */\n  get blockData() {\n    return __privateGet(this, _blockData).snapshot();\n  }\n  // Used to brand transaction classes so that they can be identified, even between multiple copies\n  // of the builder.\n  get [TRANSACTION_BRAND]() {\n    return true;\n  }\n  // Temporary workaround for the wallet interface accidentally serializing transaction blocks via postMessage\n  get pure() {\n    Object.defineProperty(this, \"pure\", {\n      enumerable: false,\n      value: createPure((value, type) => {\n        if (isSerializedBcs(value)) {\n          return __privateMethod(this, _input, input_fn).call(this, \"pure\", {\n            Pure: Array.from(value.toBytes())\n          });\n        }\n        return __privateMethod(this, _input, input_fn).call(this, \"pure\", value instanceof Uint8Array ? Inputs.Pure(value) : type ? Inputs.Pure(value, type) : value);\n      })\n    });\n    return this.pure;\n  }\n  /** Returns an argument for the gas coin, to be used in a transaction. */\n  get gas() {\n    return {\n      kind: \"GasCoin\"\n    };\n  }\n  /**\n   * Add a new object input to the transaction.\n   */\n  object(value) {\n    if (typeof value === \"object\" && \"kind\" in value) {\n      return value;\n    }\n    const id = getIdFromCallArg(value);\n    const inserted = __privateGet(this, _blockData).inputs.find(i => i.type === \"object\" && id === getIdFromCallArg(i.value));\n    return inserted ?? __privateMethod(this, _input, input_fn).call(this, \"object\", typeof value === \"string\" ? normalizeSuiAddress(value) : value);\n  }\n  /**\n   * Add a new object input to the transaction using the fully-resolved object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  objectRef(...args) {\n    return this.object(Inputs.ObjectRef(...args));\n  }\n  /**\n   * Add a new receiving input to the transaction using the fully-resolved object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  receivingRef(...args) {\n    return this.object(Inputs.ReceivingRef(...args));\n  }\n  /**\n   * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  sharedObjectRef(...args) {\n    return this.object(Inputs.SharedObjectRef(...args));\n  }\n  /** Add a transaction to the transaction block. */\n  add(transaction) {\n    const index = __privateGet(this, _blockData).transactions.push(transaction);\n    return createTransactionResult(index - 1);\n  }\n  // Method shorthands:\n  splitCoins(coin, amounts) {\n    return this.add(Transactions.SplitCoins(typeof coin === \"string\" ? this.object(coin) : coin, amounts.map(amount => typeof amount === \"number\" || typeof amount === \"bigint\" || typeof amount === \"string\" ? this.pure.u64(amount) : __privateMethod(this, _normalizeTransactionArgument, normalizeTransactionArgument_fn).call(this, amount))));\n  }\n  mergeCoins(destination, sources) {\n    return this.add(Transactions.MergeCoins(typeof destination === \"string\" ? this.object(destination) : destination, sources.map(src => typeof src === \"string\" ? this.object(src) : src)));\n  }\n  publish({\n    modules,\n    dependencies\n  }) {\n    return this.add(Transactions.Publish({\n      modules,\n      dependencies\n    }));\n  }\n  upgrade({\n    modules,\n    dependencies,\n    packageId,\n    ticket\n  }) {\n    return this.add(Transactions.Upgrade({\n      modules,\n      dependencies,\n      packageId,\n      ticket: typeof ticket === \"string\" ? this.object(ticket) : ticket\n    }));\n  }\n  moveCall({\n    arguments: args,\n    typeArguments,\n    target\n  }) {\n    return this.add(Transactions.MoveCall({\n      arguments: args?.map(arg => __privateMethod(this, _normalizeTransactionArgument, normalizeTransactionArgument_fn).call(this, arg)),\n      typeArguments,\n      target\n    }));\n  }\n  transferObjects(objects, address) {\n    return this.add(Transactions.TransferObjects(objects.map(obj => typeof obj === \"string\" ? this.object(obj) : obj), typeof address === \"string\" ? this.pure.address(address) : __privateMethod(this, _normalizeTransactionArgument, normalizeTransactionArgument_fn).call(this, address)));\n  }\n  makeMoveVec({\n    type,\n    objects\n  }) {\n    return this.add(Transactions.MakeMoveVec({\n      type,\n      objects: objects.map(obj => typeof obj === \"string\" ? this.object(obj) : obj)\n    }));\n  }\n  /**\n   * Serialize the transaction to a string so that it can be sent to a separate context.\n   * This is different from `build` in that it does not serialize to BCS bytes, and instead\n   * uses a separate format that is unique to the transaction builder. This allows\n   * us to serialize partially-complete transactions, that can then be completed and\n   * built in a separate context.\n   *\n   * For example, a dapp can construct a transaction, but not provide gas objects\n   * or a gas budget. The transaction then can be sent to the wallet, where this\n   * information is automatically filled in (e.g. by querying for coin objects\n   * and performing a dry run).\n   */\n  serialize() {\n    return JSON.stringify(__privateGet(this, _blockData).snapshot());\n  }\n  /** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n  async sign(options) {\n    const {\n      signer,\n      ...buildOptions\n    } = options;\n    const bytes = await this.build(buildOptions);\n    return signer.signTransactionBlock(bytes);\n  }\n  /** Build the transaction to BCS bytes. */\n  async build(options = {}) {\n    await __privateMethod(this, _prepare, prepare_fn).call(this, options);\n    return __privateGet(this, _blockData).build({\n      maxSizeBytes: __privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxTxSizeBytes\", options),\n      onlyTransactionKind: options.onlyTransactionKind\n    });\n  }\n  /** Derive transaction digest */\n  async getDigest(options = {}) {\n    await __privateMethod(this, _prepare, prepare_fn).call(this, options);\n    return __privateGet(this, _blockData).getDigest();\n  }\n};\nlet TransactionBlock = _TransactionBlock;\n_blockData = new WeakMap();\n_input = new WeakSet();\ninput_fn = function (type, value) {\n  const index = __privateGet(this, _blockData).inputs.length;\n  const input = create({\n    kind: \"Input\",\n    // bigints can't be serialized to JSON, so just string-convert them here:\n    value: typeof value === \"bigint\" ? String(value) : value,\n    index,\n    type\n  }, TransactionBlockInput);\n  __privateGet(this, _blockData).inputs.push(input);\n  return input;\n};\n_normalizeTransactionArgument = new WeakSet();\nnormalizeTransactionArgument_fn = function (arg) {\n  if (isSerializedBcs(arg)) {\n    return this.pure(arg);\n  }\n  return arg;\n};\n_getConfig = new WeakSet();\ngetConfig_fn = function (key, {\n  protocolConfig,\n  limits\n}) {\n  if (limits && typeof limits[key] === \"number\") {\n    return limits[key];\n  }\n  if (!protocolConfig) {\n    return DefaultOfflineLimits[key];\n  }\n  const attribute = protocolConfig?.attributes[LIMITS[key]];\n  if (!attribute) {\n    throw new Error(`Missing expected protocol config: \"${LIMITS[key]}\"`);\n  }\n  const value = \"u64\" in attribute ? attribute.u64 : \"u32\" in attribute ? attribute.u32 : attribute.f64;\n  if (!value) {\n    throw new Error(`Unexpected protocol config value found for: \"${LIMITS[key]}\"`);\n  }\n  return Number(value);\n};\n_validate = new WeakSet();\nvalidate_fn = function (options) {\n  const maxPureArgumentSize = __privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxPureArgumentSize\", options);\n  __privateGet(this, _blockData).inputs.forEach((input, index) => {\n    if (is(input.value, PureCallArg)) {\n      if (input.value.Pure.length > maxPureArgumentSize) {\n        throw new Error(`Input at index ${index} is too large, max pure input size is ${maxPureArgumentSize} bytes, got ${input.value.Pure.length} bytes`);\n      }\n    }\n  });\n};\n_prepareGasPayment = new WeakSet();\nprepareGasPayment_fn = async function (options) {\n  if (__privateGet(this, _blockData).gasConfig.payment) {\n    const maxGasObjects = __privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxGasObjects\", options);\n    if (__privateGet(this, _blockData).gasConfig.payment.length > maxGasObjects) {\n      throw new Error(`Payment objects exceed maximum amount: ${maxGasObjects}`);\n    }\n  }\n  if (options.onlyTransactionKind || __privateGet(this, _blockData).gasConfig.payment) {\n    return;\n  }\n  const gasOwner = __privateGet(this, _blockData).gasConfig.owner ?? __privateGet(this, _blockData).sender;\n  const coins = await expectClient(options).getCoins({\n    owner: gasOwner,\n    coinType: SUI_TYPE_ARG\n  });\n  const paymentCoins = coins.data.filter(coin => {\n    const matchingInput = __privateGet(this, _blockData).inputs.find(input => {\n      if (is(input.value, BuilderCallArg) && \"Object\" in input.value && \"ImmOrOwned\" in input.value.Object) {\n        return coin.coinObjectId === input.value.Object.ImmOrOwned.objectId;\n      }\n      return false;\n    });\n    return !matchingInput;\n  }).slice(0, __privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxGasObjects\", options) - 1).map(coin => ({\n    objectId: coin.coinObjectId,\n    digest: coin.digest,\n    version: coin.version\n  }));\n  if (!paymentCoins.length) {\n    throw new Error(\"No valid gas coins found for the transaction.\");\n  }\n  this.setGasPayment(paymentCoins);\n};\n_prepareGasPrice = new WeakSet();\nprepareGasPrice_fn = async function (options) {\n  if (options.onlyTransactionKind || __privateGet(this, _blockData).gasConfig.price) {\n    return;\n  }\n  this.setGasPrice(await expectClient(options).getReferenceGasPrice());\n};\n_prepareTransactions = new WeakSet();\nprepareTransactions_fn = async function (options) {\n  const {\n    inputs,\n    transactions\n  } = __privateGet(this, _blockData);\n  const moveModulesToResolve = [];\n  const objectsToResolve = [];\n  inputs.forEach(input => {\n    if (input.type === \"object\" && typeof input.value === \"string\") {\n      objectsToResolve.push({\n        id: normalizeSuiAddress(input.value),\n        input\n      });\n      return;\n    }\n  });\n  transactions.forEach(transaction => {\n    if (transaction.kind === \"MoveCall\") {\n      const needsResolution = transaction.arguments.some(arg => arg.kind === \"Input\" && !is(inputs[arg.index].value, BuilderCallArg));\n      if (needsResolution) {\n        moveModulesToResolve.push(transaction);\n      }\n    }\n    if (transaction.kind === \"SplitCoins\") {\n      transaction.amounts.forEach(amount => {\n        if (amount.kind === \"Input\") {\n          const input = inputs[amount.index];\n          if (typeof input.value !== \"object\") {\n            input.value = Inputs.Pure(bcs.U64.serialize(input.value));\n          }\n        }\n      });\n    }\n    if (transaction.kind === \"TransferObjects\") {\n      if (transaction.address.kind === \"Input\") {\n        const input = inputs[transaction.address.index];\n        if (typeof input.value !== \"object\") {\n          input.value = Inputs.Pure(bcs.Address.serialize(input.value));\n        }\n      }\n    }\n  });\n  if (moveModulesToResolve.length) {\n    await Promise.all(moveModulesToResolve.map(async moveCall => {\n      const [packageId, moduleName, functionName] = moveCall.target.split(\"::\");\n      const normalized = await expectClient(options).getNormalizedMoveFunction({\n        package: normalizeSuiObjectId(packageId),\n        module: moduleName,\n        function: functionName\n      });\n      const hasTxContext = normalized.parameters.length > 0 && isTxContext(normalized.parameters.at(-1));\n      const params = hasTxContext ? normalized.parameters.slice(0, normalized.parameters.length - 1) : normalized.parameters;\n      if (params.length !== moveCall.arguments.length) {\n        throw new Error(\"Incorrect number of arguments.\");\n      }\n      params.forEach((param, i) => {\n        const arg = moveCall.arguments[i];\n        if (arg.kind !== \"Input\") return;\n        const input = inputs[arg.index];\n        if (is(input.value, BuilderCallArg)) return;\n        const inputValue = input.value;\n        const serType = getPureSerializationType(param, inputValue);\n        if (serType) {\n          input.value = Inputs.Pure(inputValue, serType);\n          return;\n        }\n        const structVal = extractStructTag(param);\n        if (structVal != null || typeof param === \"object\" && \"TypeParameter\" in param) {\n          if (typeof inputValue !== \"string\") {\n            throw new Error(`Expect the argument to be an object id string, got ${JSON.stringify(inputValue, null, 2)}`);\n          }\n          objectsToResolve.push({\n            id: inputValue,\n            input,\n            normalizedType: param\n          });\n          return;\n        }\n        throw new Error(`Unknown call arg type ${JSON.stringify(param, null, 2)} for value ${JSON.stringify(inputValue, null, 2)}`);\n      });\n    }));\n  }\n  if (objectsToResolve.length) {\n    const dedupedIds = [...new Set(objectsToResolve.map(({\n      id\n    }) => id))];\n    const objectChunks = chunk(dedupedIds, MAX_OBJECTS_PER_FETCH);\n    const objects = (await Promise.all(objectChunks.map(chunk2 => expectClient(options).multiGetObjects({\n      ids: chunk2,\n      options: {\n        showOwner: true\n      }\n    })))).flat();\n    let objectsById = new Map(dedupedIds.map((id, index) => {\n      return [id, objects[index]];\n    }));\n    const invalidObjects = Array.from(objectsById).filter(([_, obj]) => obj.error).map(([id, _]) => id);\n    if (invalidObjects.length) {\n      throw new Error(`The following input objects are invalid: ${invalidObjects.join(\", \")}`);\n    }\n    objectsToResolve.forEach(({\n      id,\n      input,\n      normalizedType\n    }) => {\n      const object = objectsById.get(id);\n      const owner = object.data?.owner;\n      const initialSharedVersion = owner && typeof owner === \"object\" && \"Shared\" in owner ? owner.Shared.initial_shared_version : void 0;\n      if (initialSharedVersion) {\n        const isByValue = normalizedType != null && extractMutableReference(normalizedType) == null && extractReference(normalizedType) == null;\n        const mutable = isMutableSharedObjectInput(input.value) || isByValue || normalizedType != null && extractMutableReference(normalizedType) != null;\n        input.value = Inputs.SharedObjectRef({\n          objectId: id,\n          initialSharedVersion,\n          mutable\n        });\n      } else if (normalizedType && isReceivingType(normalizedType)) {\n        input.value = Inputs.ReceivingRef(getObjectReference(object));\n      } else {\n        input.value = Inputs.ObjectRef(getObjectReference(object));\n      }\n    });\n  }\n};\n_prepare = new WeakSet();\nprepare_fn = async function (options) {\n  if (!options.onlyTransactionKind && !__privateGet(this, _blockData).sender) {\n    throw new Error(\"Missing transaction sender\");\n  }\n  if (!options.protocolConfig && !options.limits && options.client) {\n    options.protocolConfig = await options.client.getProtocolConfig();\n  }\n  await Promise.all([__privateMethod(this, _prepareGasPrice, prepareGasPrice_fn).call(this, options), __privateMethod(this, _prepareTransactions, prepareTransactions_fn).call(this, options)]);\n  if (!options.onlyTransactionKind) {\n    await __privateMethod(this, _prepareGasPayment, prepareGasPayment_fn).call(this, options);\n    if (!__privateGet(this, _blockData).gasConfig.budget) {\n      const dryRunResult = await expectClient(options).dryRunTransactionBlock({\n        transactionBlock: __privateGet(this, _blockData).build({\n          maxSizeBytes: __privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxTxSizeBytes\", options),\n          overrides: {\n            gasConfig: {\n              budget: String(__privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxTxGas\", options)),\n              payment: []\n            }\n          }\n        })\n      });\n      if (dryRunResult.effects.status.status !== \"success\") {\n        throw new Error(`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`, {\n          cause: dryRunResult\n        });\n      }\n      const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(this.blockData.gasConfig.price || 1n);\n      const baseComputationCostWithOverhead = BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n      const gasBudget = baseComputationCostWithOverhead + BigInt(dryRunResult.effects.gasUsed.storageCost) - BigInt(dryRunResult.effects.gasUsed.storageRebate);\n      this.setGasBudget(gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead);\n    }\n  }\n  __privateMethod(this, _validate, validate_fn).call(this, options);\n};\nexport { TransactionBlock, isTransactionBlock };","map":{"version":3,"names":["_blockData","_input","input_fn","_normalizeTransactionArgument","normalizeTransactionArgument_fn","_getConfig","getConfig_fn","_validate","validate_fn","_prepareGasPayment","prepareGasPayment_fn","_prepareGasPrice","prepareGasPrice_fn","_prepareTransactions","prepareTransactions_fn","_prepare","prepare_fn","fromB64","isSerializedBcs","is","mask","bcs","extractMutableReference","extractReference","extractStructTag","getObjectReference","SuiObjectRef","SUI_TYPE_ARG","normalizeSuiAddress","normalizeSuiObjectId","BuilderCallArg","getIdFromCallArg","Inputs","isMutableSharedObjectInput","PureCallArg","createPure","getPureSerializationType","isTxContext","TransactionBlockDataBuilder","TransactionBlockInput","Transactions","create","DefaultOfflineLimits","maxPureArgumentSize","maxTxGas","maxGasObjects","maxTxSizeBytes","createTransactionResult","index","baseResult","kind","nestedResults","nestedResultFor","resultIndex","Proxy","set","Error","get","target","property","Reflect","Symbol","iterator","i","parseInt","Number","isNaN","isReceivingType","normalizedType","tag","Struct","address","module","name","expectClient","options","client","TRANSACTION_BRAND","for","LIMITS","GAS_SAFE_OVERHEAD","MAX_OBJECTS_PER_FETCH","chunk","arr","size","Array","from","length","Math","ceil","_","slice","isTransactionBlock","obj","_TransactionBlock","constructor","transaction","__privateAdd","__privateSet","blockData","fromKind","serialized","tx","fromKindBytes","startsWith","fromBytes","restore","JSON","parse","setSender","sender","__privateGet","setSenderIfNotSet","setExpiration","expiration","setGasPrice","price","gasConfig","String","setGasBudget","budget","setGasOwner","owner","setGasPayment","payments","payment","map","snapshot","pure","Object","defineProperty","enumerable","value","type","__privateMethod","call","Pure","toBytes","Uint8Array","gas","object","id","inserted","inputs","find","objectRef","args","ObjectRef","receivingRef","ReceivingRef","sharedObjectRef","SharedObjectRef","add","transactions","push","splitCoins","coin","amounts","SplitCoins","amount","u64","mergeCoins","destination","sources","MergeCoins","src","publish","modules","dependencies","Publish","upgrade","packageId","ticket","Upgrade","moveCall","arguments","typeArguments","MoveCall","arg","transferObjects","objects","TransferObjects","makeMoveVec","MakeMoveVec","serialize","stringify","sign","signer","buildOptions","bytes","build","signTransactionBlock","maxSizeBytes","onlyTransactionKind","getDigest","TransactionBlock","WeakMap","WeakSet","input","key","protocolConfig","limits","attribute","attributes","u32","f64","forEach","gasOwner","coins","getCoins","coinType","paymentCoins","data","filter","matchingInput","coinObjectId","ImmOrOwned","objectId","digest","version","getReferenceGasPrice","moveModulesToResolve","objectsToResolve","needsResolution","some","U64","Address","Promise","all","moduleName","functionName","split","normalized","getNormalizedMoveFunction","package","function","hasTxContext","parameters","at","params","param","inputValue","serType","structVal","dedupedIds","Set","objectChunks","chunk2","multiGetObjects","ids","showOwner","flat","objectsById","Map","invalidObjects","error","join","initialSharedVersion","Shared","initial_shared_version","isByValue","mutable","getProtocolConfig","dryRunResult","dryRunTransactionBlock","transactionBlock","overrides","effects","status","cause","safeOverhead","BigInt","baseComputationCostWithOverhead","gasUsed","computationCost","gasBudget","storageCost","storageRebate"],"sources":["/home/andrei/proiect-itb/token/frontend/node_modules/@mysten/sui.js/src/builder/TransactionBlock.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\nimport { fromB64, isSerializedBcs } from '@mysten/bcs';\nimport { is, mask } from 'superstruct';\n\nimport { bcs } from '../bcs/index.js';\nimport type { ProtocolConfig, SuiClient, SuiMoveNormalizedType } from '../client/index.js';\nimport type { Keypair, SignatureWithBytes } from '../cryptography/index.js';\nimport type { SuiObjectResponse } from '../types/index.js';\nimport {\n\textractMutableReference,\n\textractReference,\n\textractStructTag,\n\tgetObjectReference,\n\tSuiObjectRef,\n} from '../types/index.js';\nimport { SUI_TYPE_ARG } from '../utils/index.js';\nimport { normalizeSuiAddress, normalizeSuiObjectId } from '../utils/sui-types.js';\nimport type { ObjectCallArg } from './Inputs.js';\nimport {\n\tBuilderCallArg,\n\tgetIdFromCallArg,\n\tInputs,\n\tisMutableSharedObjectInput,\n\tPureCallArg,\n} from './Inputs.js';\nimport { createPure } from './pure.js';\nimport { getPureSerializationType, isTxContext } from './serializer.js';\nimport type { TransactionExpiration } from './TransactionBlockData.js';\nimport { TransactionBlockDataBuilder } from './TransactionBlockData.js';\nimport type { MoveCallTransaction, TransactionArgument, TransactionType } from './Transactions.js';\nimport { TransactionBlockInput, Transactions } from './Transactions.js';\nimport { create } from './utils.js';\n\nexport type TransactionObjectArgument = Exclude<\n\tTransactionArgument,\n\t{ kind: 'Input'; type: 'pure' }\n>;\n\nexport type TransactionResult = Extract<TransactionArgument, { kind: 'Result' }> &\n\tExtract<TransactionArgument, { kind: 'NestedResult' }>[];\n\nconst DefaultOfflineLimits = {\n\tmaxPureArgumentSize: 16 * 1024,\n\tmaxTxGas: 50_000_000_000,\n\tmaxGasObjects: 256,\n\tmaxTxSizeBytes: 128 * 1024,\n} satisfies Limits;\n\nfunction createTransactionResult(index: number): TransactionResult {\n\tconst baseResult: TransactionArgument = { kind: 'Result', index };\n\n\tconst nestedResults: TransactionArgument[] = [];\n\tconst nestedResultFor = (resultIndex: number): TransactionArgument =>\n\t\t(nestedResults[resultIndex] ??= {\n\t\t\tkind: 'NestedResult',\n\t\t\tindex,\n\t\t\tresultIndex,\n\t\t});\n\n\treturn new Proxy(baseResult, {\n\t\tset() {\n\t\t\tthrow new Error(\n\t\t\t\t'The transaction result is a proxy, and does not support setting properties directly',\n\t\t\t);\n\t\t},\n\t\t// TODO: Instead of making this return a concrete argument, we should ideally\n\t\t// make it reference-based (so that this gets resolved at build-time), which\n\t\t// allows re-ordering transactions.\n\t\tget(target, property) {\n\t\t\t// This allows this transaction argument to be used in the singular form:\n\t\t\tif (property in target) {\n\t\t\t\treturn Reflect.get(target, property);\n\t\t\t}\n\n\t\t\t// Support destructuring:\n\t\t\tif (property === Symbol.iterator) {\n\t\t\t\treturn function* () {\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tyield nestedResultFor(i);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (typeof property === 'symbol') return;\n\n\t\t\tconst resultIndex = parseInt(property, 10);\n\t\t\tif (Number.isNaN(resultIndex) || resultIndex < 0) return;\n\t\t\treturn nestedResultFor(resultIndex);\n\t\t},\n\t}) as TransactionResult;\n}\n\nfunction isReceivingType(normalizedType: SuiMoveNormalizedType): boolean {\n\tconst tag = extractStructTag(normalizedType);\n\tif (tag) {\n\t\treturn (\n\t\t\ttag.Struct.address === '0x2' &&\n\t\t\ttag.Struct.module === 'transfer' &&\n\t\t\ttag.Struct.name === 'Receiving'\n\t\t);\n\t}\n\treturn false;\n}\n\nfunction expectClient(options: BuildOptions): SuiClient {\n\tif (!options.client) {\n\t\tthrow new Error(\n\t\t\t`No provider passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n\t\t);\n\t}\n\n\treturn options.client;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@mysten/transaction');\n\nconst LIMITS = {\n\t// The maximum gas that is allowed.\n\tmaxTxGas: 'max_tx_gas',\n\t// The maximum number of gas objects that can be selected for one transaction.\n\tmaxGasObjects: 'max_gas_payment_objects',\n\t// The maximum size (in bytes) that the transaction can be:\n\tmaxTxSizeBytes: 'max_tx_size_bytes',\n\t// The maximum size (in bytes) that pure arguments can be:\n\tmaxPureArgumentSize: 'max_pure_argument_size',\n} as const;\n\ntype Limits = Partial<Record<keyof typeof LIMITS, number>>;\n\n// An amount of gas (in gas units) that is added to transactions as an overhead to ensure transactions do not fail.\nconst GAS_SAFE_OVERHEAD = 1000n;\n\n// The maximum objects that can be fetched at once using multiGetObjects.\nconst MAX_OBJECTS_PER_FETCH = 50;\n\nconst chunk = <T>(arr: T[], size: number): T[][] =>\n\tArray.from({ length: Math.ceil(arr.length / size) }, (_, i) =>\n\t\tarr.slice(i * size, i * size + size),\n\t);\n\ninterface BuildOptions {\n\tclient?: SuiClient;\n\tonlyTransactionKind?: boolean;\n\t/** Define a protocol config to build against, instead of having it fetched from the provider at build time. */\n\tprotocolConfig?: ProtocolConfig;\n\t/** Define limits that are used when building the transaction. In general, we recommend using the protocol configuration instead of defining limits. */\n\tlimits?: Limits;\n}\n\ninterface SignOptions extends BuildOptions {\n\tsigner: Keypair;\n}\n\nexport function isTransactionBlock(obj: unknown): obj is TransactionBlock {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n}\n\nexport type TransactionObjectInput = string | ObjectCallArg | TransactionObjectArgument;\n\n/**\n * Transaction Builder\n */\nexport class TransactionBlock {\n\t/**\n\t * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n\t * Supports either a byte array, or base64-encoded bytes.\n\t */\n\tstatic fromKind(serialized: string | Uint8Array) {\n\t\tconst tx = new TransactionBlock();\n\n\t\ttx.#blockData = TransactionBlockDataBuilder.fromKindBytes(\n\t\t\ttypeof serialized === 'string' ? fromB64(serialized) : serialized,\n\t\t);\n\n\t\treturn tx;\n\t}\n\n\t/**\n\t * Converts from a serialized transaction format to a `Transaction` class.\n\t * There are two supported serialized formats:\n\t * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n\t * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n\t */\n\tstatic from(serialized: string | Uint8Array) {\n\t\tconst tx = new TransactionBlock();\n\n\t\t// Check for bytes:\n\t\tif (typeof serialized !== 'string' || !serialized.startsWith('{')) {\n\t\t\ttx.#blockData = TransactionBlockDataBuilder.fromBytes(\n\t\t\t\ttypeof serialized === 'string' ? fromB64(serialized) : serialized,\n\t\t\t);\n\t\t} else {\n\t\t\ttx.#blockData = TransactionBlockDataBuilder.restore(JSON.parse(serialized));\n\t\t}\n\n\t\treturn tx;\n\t}\n\n\tsetSender(sender: string) {\n\t\tthis.#blockData.sender = sender;\n\t}\n\t/**\n\t * Sets the sender only if it has not already been set.\n\t * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n\t */\n\tsetSenderIfNotSet(sender: string) {\n\t\tif (!this.#blockData.sender) {\n\t\t\tthis.#blockData.sender = sender;\n\t\t}\n\t}\n\tsetExpiration(expiration?: TransactionExpiration) {\n\t\tthis.#blockData.expiration = expiration;\n\t}\n\tsetGasPrice(price: number | bigint) {\n\t\tthis.#blockData.gasConfig.price = String(price);\n\t}\n\tsetGasBudget(budget: number | bigint) {\n\t\tthis.#blockData.gasConfig.budget = String(budget);\n\t}\n\tsetGasOwner(owner: string) {\n\t\tthis.#blockData.gasConfig.owner = owner;\n\t}\n\tsetGasPayment(payments: SuiObjectRef[]) {\n\t\tthis.#blockData.gasConfig.payment = payments.map((payment) => mask(payment, SuiObjectRef));\n\t}\n\n\t#blockData: TransactionBlockDataBuilder;\n\t/** Get a snapshot of the transaction data, in JSON form: */\n\tget blockData() {\n\t\treturn this.#blockData.snapshot();\n\t}\n\n\t// Used to brand transaction classes so that they can be identified, even between multiple copies\n\t// of the builder.\n\tget [TRANSACTION_BRAND]() {\n\t\treturn true;\n\t}\n\n\t// Temporary workaround for the wallet interface accidentally serializing transaction blocks via postMessage\n\tget pure(): ReturnType<typeof createPure> {\n\t\tObject.defineProperty(this, 'pure', {\n\t\t\tenumerable: false,\n\t\t\tvalue: createPure((value, type) => {\n\t\t\t\tif (isSerializedBcs(value)) {\n\t\t\t\t\treturn this.#input('pure', {\n\t\t\t\t\t\tPure: Array.from(value.toBytes()),\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// TODO: we can also do some deduplication here\n\t\t\t\treturn this.#input(\n\t\t\t\t\t'pure',\n\t\t\t\t\tvalue instanceof Uint8Array\n\t\t\t\t\t\t? Inputs.Pure(value)\n\t\t\t\t\t\t: type\n\t\t\t\t\t\t? Inputs.Pure(value, type)\n\t\t\t\t\t\t: value,\n\t\t\t\t);\n\t\t\t}),\n\t\t});\n\n\t\treturn this.pure;\n\t}\n\n\tconstructor(transaction?: TransactionBlock) {\n\t\tthis.#blockData = new TransactionBlockDataBuilder(\n\t\t\ttransaction ? transaction.blockData : undefined,\n\t\t);\n\t}\n\n\t/** Returns an argument for the gas coin, to be used in a transaction. */\n\tget gas(): TransactionObjectArgument {\n\t\treturn { kind: 'GasCoin' };\n\t}\n\n\t/**\n\t * Dynamically create a new input, which is separate from the `input`. This is important\n\t * for generated clients to be able to define unique inputs that are non-overlapping with the\n\t * defined inputs.\n\t *\n\t * For `Uint8Array` type automatically convert the input into a `Pure` CallArg, since this\n\t * is the format required for custom serialization.\n\t *\n\t */\n\t#input<T extends 'object' | 'pure'>(type: T, value?: unknown) {\n\t\tconst index = this.#blockData.inputs.length;\n\t\tconst input = create(\n\t\t\t{\n\t\t\t\tkind: 'Input',\n\t\t\t\t// bigints can't be serialized to JSON, so just string-convert them here:\n\t\t\t\tvalue: typeof value === 'bigint' ? String(value) : value,\n\t\t\t\tindex,\n\t\t\t\ttype,\n\t\t\t},\n\t\t\tTransactionBlockInput,\n\t\t);\n\t\tthis.#blockData.inputs.push(input);\n\t\treturn input as Extract<typeof input, { type: T }>;\n\t}\n\n\t/**\n\t * Add a new object input to the transaction.\n\t */\n\tobject(value: TransactionObjectInput) {\n\t\tif (typeof value === 'object' && 'kind' in value) {\n\t\t\treturn value;\n\t\t}\n\n\t\tconst id = getIdFromCallArg(value);\n\t\t// deduplicate\n\t\tconst inserted = this.#blockData.inputs.find(\n\t\t\t(i) => i.type === 'object' && id === getIdFromCallArg(i.value),\n\t\t) as Extract<TransactionArgument, { type?: 'object' }> | undefined;\n\t\treturn (\n\t\t\tinserted ??\n\t\t\tthis.#input('object', typeof value === 'string' ? normalizeSuiAddress(value) : value)\n\t\t);\n\t}\n\n\t/**\n\t * Add a new object input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tobjectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n\t\treturn this.object(Inputs.ObjectRef(...args));\n\t}\n\n\t/**\n\t * Add a new receiving input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\treceivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>) {\n\t\treturn this.object(Inputs.ReceivingRef(...args));\n\t}\n\n\t/**\n\t * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tsharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n\t\treturn this.object(Inputs.SharedObjectRef(...args));\n\t}\n\n\t/** Add a transaction to the transaction block. */\n\tadd(transaction: TransactionType) {\n\t\tconst index = this.#blockData.transactions.push(transaction);\n\t\treturn createTransactionResult(index - 1);\n\t}\n\n\t#normalizeTransactionArgument(\n\t\targ: TransactionArgument | SerializedBcs<any>,\n\t): TransactionArgument {\n\t\tif (isSerializedBcs(arg)) {\n\t\t\treturn this.pure(arg);\n\t\t}\n\n\t\treturn arg as TransactionArgument;\n\t}\n\n\t// Method shorthands:\n\n\tsplitCoins(\n\t\tcoin: TransactionObjectArgument | string,\n\t\tamounts: (TransactionArgument | SerializedBcs<any> | number | string | bigint)[],\n\t) {\n\t\treturn this.add(\n\t\t\tTransactions.SplitCoins(\n\t\t\t\ttypeof coin === 'string' ? this.object(coin) : coin,\n\t\t\t\tamounts.map((amount) =>\n\t\t\t\t\ttypeof amount === 'number' || typeof amount === 'bigint' || typeof amount === 'string'\n\t\t\t\t\t\t? this.pure.u64(amount)\n\t\t\t\t\t\t: this.#normalizeTransactionArgument(amount),\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n\tmergeCoins(\n\t\tdestination: TransactionObjectArgument | string,\n\t\tsources: (TransactionObjectArgument | string)[],\n\t) {\n\t\treturn this.add(\n\t\t\tTransactions.MergeCoins(\n\t\t\t\ttypeof destination === 'string' ? this.object(destination) : destination,\n\t\t\t\tsources.map((src) => (typeof src === 'string' ? this.object(src) : src)),\n\t\t\t),\n\t\t);\n\t}\n\tpublish({ modules, dependencies }: { modules: number[][] | string[]; dependencies: string[] }) {\n\t\treturn this.add(\n\t\t\tTransactions.Publish({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t}),\n\t\t);\n\t}\n\tupgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackageId: string;\n\t\tticket: TransactionObjectArgument | string;\n\t}) {\n\t\treturn this.add(\n\t\t\tTransactions.Upgrade({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t\tpackageId,\n\t\t\t\tticket: typeof ticket === 'string' ? this.object(ticket) : ticket,\n\t\t\t}),\n\t\t);\n\t}\n\tmoveCall({\n\t\targuments: args,\n\t\ttypeArguments,\n\t\ttarget,\n\t}: {\n\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\ttypeArguments?: string[];\n\t\ttarget: `${string}::${string}::${string}`;\n\t}) {\n\t\treturn this.add(\n\t\t\tTransactions.MoveCall({\n\t\t\t\targuments: args?.map((arg) => this.#normalizeTransactionArgument(arg)),\n\t\t\t\ttypeArguments,\n\t\t\t\ttarget,\n\t\t\t}),\n\t\t);\n\t}\n\ttransferObjects(\n\t\tobjects: (TransactionObjectArgument | string)[],\n\t\taddress: TransactionArgument | SerializedBcs<any> | string,\n\t) {\n\t\treturn this.add(\n\t\t\tTransactions.TransferObjects(\n\t\t\t\tobjects.map((obj) => (typeof obj === 'string' ? this.object(obj) : obj)),\n\t\t\t\ttypeof address === 'string'\n\t\t\t\t\t? this.pure.address(address)\n\t\t\t\t\t: this.#normalizeTransactionArgument(address),\n\t\t\t),\n\t\t);\n\t}\n\tmakeMoveVec({\n\t\ttype,\n\t\tobjects,\n\t}: {\n\t\tobjects: (TransactionObjectArgument | string)[];\n\t\ttype?: string;\n\t}) {\n\t\treturn this.add(\n\t\t\tTransactions.MakeMoveVec({\n\t\t\t\ttype,\n\t\t\t\tobjects: objects.map((obj) => (typeof obj === 'string' ? this.object(obj) : obj)),\n\t\t\t}),\n\t\t);\n\t}\n\n\t/**\n\t * Serialize the transaction to a string so that it can be sent to a separate context.\n\t * This is different from `build` in that it does not serialize to BCS bytes, and instead\n\t * uses a separate format that is unique to the transaction builder. This allows\n\t * us to serialize partially-complete transactions, that can then be completed and\n\t * built in a separate context.\n\t *\n\t * For example, a dapp can construct a transaction, but not provide gas objects\n\t * or a gas budget. The transaction then can be sent to the wallet, where this\n\t * information is automatically filled in (e.g. by querying for coin objects\n\t * and performing a dry run).\n\t */\n\tserialize() {\n\t\treturn JSON.stringify(this.#blockData.snapshot());\n\t}\n\n\t#getConfig(key: keyof typeof LIMITS, { protocolConfig, limits }: BuildOptions) {\n\t\t// Use the limits definition if that exists:\n\t\tif (limits && typeof limits[key] === 'number') {\n\t\t\treturn limits[key]!;\n\t\t}\n\n\t\tif (!protocolConfig) {\n\t\t\treturn DefaultOfflineLimits[key];\n\t\t}\n\n\t\t// Fallback to protocol config:\n\t\tconst attribute = protocolConfig?.attributes[LIMITS[key]];\n\t\tif (!attribute) {\n\t\t\tthrow new Error(`Missing expected protocol config: \"${LIMITS[key]}\"`);\n\t\t}\n\n\t\tconst value =\n\t\t\t'u64' in attribute ? attribute.u64 : 'u32' in attribute ? attribute.u32 : attribute.f64;\n\n\t\tif (!value) {\n\t\t\tthrow new Error(`Unexpected protocol config value found for: \"${LIMITS[key]}\"`);\n\t\t}\n\n\t\t// NOTE: Technically this is not a safe conversion, but we know all of the values in protocol config are safe\n\t\treturn Number(value);\n\t}\n\n\t/** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n\tasync sign(options: SignOptions): Promise<SignatureWithBytes> {\n\t\tconst { signer, ...buildOptions } = options;\n\t\tconst bytes = await this.build(buildOptions);\n\t\treturn signer.signTransactionBlock(bytes);\n\t}\n\n\t/** Build the transaction to BCS bytes. */\n\tasync build(options: BuildOptions = {}): Promise<Uint8Array> {\n\t\tawait this.#prepare(options);\n\t\treturn this.#blockData.build({\n\t\t\tmaxSizeBytes: this.#getConfig('maxTxSizeBytes', options),\n\t\t\tonlyTransactionKind: options.onlyTransactionKind,\n\t\t});\n\t}\n\n\t/** Derive transaction digest */\n\tasync getDigest(\n\t\toptions: {\n\t\t\tclient?: SuiClient;\n\t\t} = {},\n\t): Promise<string> {\n\t\tawait this.#prepare(options);\n\t\treturn this.#blockData.getDigest();\n\t}\n\n\t#validate(options: BuildOptions) {\n\t\tconst maxPureArgumentSize = this.#getConfig('maxPureArgumentSize', options);\n\t\t// Validate all inputs are the correct size:\n\t\tthis.#blockData.inputs.forEach((input, index) => {\n\t\t\tif (is(input.value, PureCallArg)) {\n\t\t\t\tif (input.value.Pure.length > maxPureArgumentSize) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Input at index ${index} is too large, max pure input size is ${maxPureArgumentSize} bytes, got ${input.value.Pure.length} bytes`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t// The current default is just picking _all_ coins we can which may not be ideal.\n\tasync #prepareGasPayment(options: BuildOptions) {\n\t\tif (this.#blockData.gasConfig.payment) {\n\t\t\tconst maxGasObjects = this.#getConfig('maxGasObjects', options);\n\t\t\tif (this.#blockData.gasConfig.payment.length > maxGasObjects) {\n\t\t\t\tthrow new Error(`Payment objects exceed maximum amount: ${maxGasObjects}`);\n\t\t\t}\n\t\t}\n\n\t\t// Early return if the payment is already set:\n\t\tif (options.onlyTransactionKind || this.#blockData.gasConfig.payment) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst gasOwner = this.#blockData.gasConfig.owner ?? this.#blockData.sender;\n\n\t\tconst coins = await expectClient(options).getCoins({\n\t\t\towner: gasOwner!,\n\t\t\tcoinType: SUI_TYPE_ARG,\n\t\t});\n\n\t\tconst paymentCoins = coins.data\n\t\t\t// Filter out coins that are also used as input:\n\t\t\t.filter((coin) => {\n\t\t\t\tconst matchingInput = this.#blockData.inputs.find((input) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tis(input.value, BuilderCallArg) &&\n\t\t\t\t\t\t'Object' in input.value &&\n\t\t\t\t\t\t'ImmOrOwned' in input.value.Object\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn coin.coinObjectId === input.value.Object.ImmOrOwned.objectId;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\n\t\t\t\treturn !matchingInput;\n\t\t\t})\n\t\t\t.slice(0, this.#getConfig('maxGasObjects', options) - 1)\n\t\t\t.map((coin) => ({\n\t\t\t\tobjectId: coin.coinObjectId,\n\t\t\t\tdigest: coin.digest,\n\t\t\t\tversion: coin.version,\n\t\t\t}));\n\n\t\tif (!paymentCoins.length) {\n\t\t\tthrow new Error('No valid gas coins found for the transaction.');\n\t\t}\n\n\t\tthis.setGasPayment(paymentCoins);\n\t}\n\n\tasync #prepareGasPrice(options: BuildOptions) {\n\t\tif (options.onlyTransactionKind || this.#blockData.gasConfig.price) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setGasPrice(await expectClient(options).getReferenceGasPrice());\n\t}\n\n\tasync #prepareTransactions(options: BuildOptions) {\n\t\tconst { inputs, transactions } = this.#blockData;\n\n\t\tconst moveModulesToResolve: MoveCallTransaction[] = [];\n\n\t\t// Keep track of the object references that will need to be resolved at the end of the transaction.\n\t\t// We keep the input by-reference to avoid needing to re-resolve it:\n\t\tconst objectsToResolve: {\n\t\t\tid: string;\n\t\t\tinput: TransactionBlockInput;\n\t\t\tnormalizedType?: SuiMoveNormalizedType;\n\t\t}[] = [];\n\n\t\tinputs.forEach((input) => {\n\t\t\tif (input.type === 'object' && typeof input.value === 'string') {\n\t\t\t\t// The input is a string that we need to resolve to an object reference:\n\t\t\t\tobjectsToResolve.push({ id: normalizeSuiAddress(input.value), input });\n\t\t\t\treturn;\n\t\t\t}\n\t\t});\n\n\t\ttransactions.forEach((transaction) => {\n\t\t\t// Special case move call:\n\t\t\tif (transaction.kind === 'MoveCall') {\n\t\t\t\t// Determine if any of the arguments require encoding.\n\t\t\t\t// - If they don't, then this is good to go.\n\t\t\t\t// - If they do, then we need to fetch the normalized move module.\n\t\t\t\tconst needsResolution = transaction.arguments.some(\n\t\t\t\t\t(arg) => arg.kind === 'Input' && !is(inputs[arg.index].value, BuilderCallArg),\n\t\t\t\t);\n\n\t\t\t\tif (needsResolution) {\n\t\t\t\t\tmoveModulesToResolve.push(transaction);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special handling for values that where previously encoded using the wellKnownEncoding pattern.\n\t\t\t// This should only happen when transaction block data was hydrated from an old version of the SDK\n\t\t\tif (transaction.kind === 'SplitCoins') {\n\t\t\t\ttransaction.amounts.forEach((amount) => {\n\t\t\t\t\tif (amount.kind === 'Input') {\n\t\t\t\t\t\tconst input = inputs[amount.index];\n\t\t\t\t\t\tif (typeof input.value !== 'object') {\n\t\t\t\t\t\t\tinput.value = Inputs.Pure(bcs.U64.serialize(input.value));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (transaction.kind === 'TransferObjects') {\n\t\t\t\tif (transaction.address.kind === 'Input') {\n\t\t\t\t\tconst input = inputs[transaction.address.index];\n\t\t\t\t\tif (typeof input.value !== 'object') {\n\t\t\t\t\t\tinput.value = Inputs.Pure(bcs.Address.serialize(input.value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (moveModulesToResolve.length) {\n\t\t\tawait Promise.all(\n\t\t\t\tmoveModulesToResolve.map(async (moveCall) => {\n\t\t\t\t\tconst [packageId, moduleName, functionName] = moveCall.target.split('::');\n\n\t\t\t\t\tconst normalized = await expectClient(options).getNormalizedMoveFunction({\n\t\t\t\t\t\tpackage: normalizeSuiObjectId(packageId),\n\t\t\t\t\t\tmodule: moduleName,\n\t\t\t\t\t\tfunction: functionName,\n\t\t\t\t\t});\n\n\t\t\t\t\t// Entry functions can have a mutable reference to an instance of the TxContext\n\t\t\t\t\t// struct defined in the TxContext module as the last parameter. The caller of\n\t\t\t\t\t// the function does not need to pass it in as an argument.\n\t\t\t\t\tconst hasTxContext =\n\t\t\t\t\t\tnormalized.parameters.length > 0 && isTxContext(normalized.parameters.at(-1)!);\n\n\t\t\t\t\tconst params = hasTxContext\n\t\t\t\t\t\t? normalized.parameters.slice(0, normalized.parameters.length - 1)\n\t\t\t\t\t\t: normalized.parameters;\n\n\t\t\t\t\tif (params.length !== moveCall.arguments.length) {\n\t\t\t\t\t\tthrow new Error('Incorrect number of arguments.');\n\t\t\t\t\t}\n\n\t\t\t\t\tparams.forEach((param, i) => {\n\t\t\t\t\t\tconst arg = moveCall.arguments[i];\n\t\t\t\t\t\tif (arg.kind !== 'Input') return;\n\t\t\t\t\t\tconst input = inputs[arg.index];\n\t\t\t\t\t\t// Skip if the input is already resolved\n\t\t\t\t\t\tif (is(input.value, BuilderCallArg)) return;\n\n\t\t\t\t\t\tconst inputValue = input.value;\n\n\t\t\t\t\t\tconst serType = getPureSerializationType(param, inputValue);\n\n\t\t\t\t\t\tif (serType) {\n\t\t\t\t\t\t\tinput.value = Inputs.Pure(inputValue, serType);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst structVal = extractStructTag(param);\n\t\t\t\t\t\tif (structVal != null || (typeof param === 'object' && 'TypeParameter' in param)) {\n\t\t\t\t\t\t\tif (typeof inputValue !== 'string') {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t`Expect the argument to be an object id string, got ${JSON.stringify(\n\t\t\t\t\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\t\t2,\n\t\t\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tobjectsToResolve.push({\n\t\t\t\t\t\t\t\tid: inputValue,\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tnormalizedType: param,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unknown call arg type ${JSON.stringify(param, null, 2)} for value ${JSON.stringify(\n\t\t\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t2,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tif (objectsToResolve.length) {\n\t\t\tconst dedupedIds = [...new Set(objectsToResolve.map(({ id }) => id))];\n\t\t\tconst objectChunks = chunk(dedupedIds, MAX_OBJECTS_PER_FETCH);\n\t\t\tconst objects = (\n\t\t\t\tawait Promise.all(\n\t\t\t\t\tobjectChunks.map((chunk) =>\n\t\t\t\t\t\texpectClient(options).multiGetObjects({\n\t\t\t\t\t\t\tids: chunk,\n\t\t\t\t\t\t\toptions: { showOwner: true },\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t).flat();\n\n\t\t\tlet objectsById = new Map(\n\t\t\t\tdedupedIds.map((id, index) => {\n\t\t\t\t\treturn [id, objects[index]];\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tconst invalidObjects = Array.from(objectsById)\n\t\t\t\t.filter(([_, obj]) => obj.error)\n\t\t\t\t.map(([id, _]) => id);\n\t\t\tif (invalidObjects.length) {\n\t\t\t\tthrow new Error(`The following input objects are invalid: ${invalidObjects.join(', ')}`);\n\t\t\t}\n\n\t\t\tobjectsToResolve.forEach(({ id, input, normalizedType }) => {\n\t\t\t\tconst object = objectsById.get(id)!;\n\t\t\t\tconst owner = object.data?.owner;\n\t\t\t\tconst initialSharedVersion =\n\t\t\t\t\towner && typeof owner === 'object' && 'Shared' in owner\n\t\t\t\t\t\t? owner.Shared.initial_shared_version\n\t\t\t\t\t\t: undefined;\n\n\t\t\t\tif (initialSharedVersion) {\n\t\t\t\t\t// There could be multiple transactions that reference the same shared object.\n\t\t\t\t\t// If one of them is a mutable reference or taken by value, then we should mark the input\n\t\t\t\t\t// as mutable.\n\t\t\t\t\tconst isByValue =\n\t\t\t\t\t\tnormalizedType != null &&\n\t\t\t\t\t\textractMutableReference(normalizedType) == null &&\n\t\t\t\t\t\textractReference(normalizedType) == null;\n\t\t\t\t\tconst mutable =\n\t\t\t\t\t\tisMutableSharedObjectInput(input.value) ||\n\t\t\t\t\t\tisByValue ||\n\t\t\t\t\t\t(normalizedType != null && extractMutableReference(normalizedType) != null);\n\n\t\t\t\t\tinput.value = Inputs.SharedObjectRef({\n\t\t\t\t\t\tobjectId: id,\n\t\t\t\t\t\tinitialSharedVersion,\n\t\t\t\t\t\tmutable,\n\t\t\t\t\t});\n\t\t\t\t} else if (normalizedType && isReceivingType(normalizedType)) {\n\t\t\t\t\tinput.value = Inputs.ReceivingRef(getObjectReference(object)!);\n\t\t\t\t} else {\n\t\t\t\t\tinput.value = Inputs.ObjectRef(getObjectReference(object as SuiObjectResponse)!);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Prepare the transaction by valdiating the transaction data and resolving all inputs\n\t * so that it can be built into bytes.\n\t */\n\tasync #prepare(options: BuildOptions) {\n\t\tif (!options.onlyTransactionKind && !this.#blockData.sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tif (!options.protocolConfig && !options.limits && options.client) {\n\t\t\toptions.protocolConfig = await options.client.getProtocolConfig();\n\t\t}\n\n\t\tawait Promise.all([this.#prepareGasPrice(options), this.#prepareTransactions(options)]);\n\n\t\tif (!options.onlyTransactionKind) {\n\t\t\tawait this.#prepareGasPayment(options);\n\n\t\t\tif (!this.#blockData.gasConfig.budget) {\n\t\t\t\tconst dryRunResult = await expectClient(options).dryRunTransactionBlock({\n\t\t\t\t\ttransactionBlock: this.#blockData.build({\n\t\t\t\t\t\tmaxSizeBytes: this.#getConfig('maxTxSizeBytes', options),\n\t\t\t\t\t\toverrides: {\n\t\t\t\t\t\t\tgasConfig: {\n\t\t\t\t\t\t\t\tbudget: String(this.#getConfig('maxTxGas', options)),\n\t\t\t\t\t\t\t\tpayment: [],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t});\n\t\t\t\tif (dryRunResult.effects.status.status !== 'success') {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n\t\t\t\t\t\t{ cause: dryRunResult },\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst safeOverhead = GAS_SAFE_OVERHEAD * BigInt(this.blockData.gasConfig.price || 1n);\n\n\t\t\t\tconst baseComputationCostWithOverhead =\n\t\t\t\t\tBigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n\n\t\t\t\tconst gasBudget =\n\t\t\t\t\tbaseComputationCostWithOverhead +\n\t\t\t\t\tBigInt(dryRunResult.effects.gasUsed.storageCost) -\n\t\t\t\t\tBigInt(dryRunResult.effects.gasUsed.storageRebate);\n\n\t\t\t\t// Set the budget to max(computation, computation + storage - rebate)\n\t\t\t\tthis.setGasBudget(\n\t\t\t\t\tgasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Perform final validation on the transaction:\n\t\tthis.#validate(options);\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}